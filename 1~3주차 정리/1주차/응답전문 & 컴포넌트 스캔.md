# 4번 손미희님



## 웹기초 : 응답 전문(헤더, 바디)
<details>
헤더는 요청 또는 응답에 대한 정보를 가지고 있는 곳이고 바디는 서버와 클라이언트 간에 주고받을 실제 데이터를 담아두는 공간입니다.

**일반 헤더(General header)** :
요청 응답에 모두 적용 가능한 헤더이다.
메시지, 연결 관리 (Connection Management), 캐싱 정책 등을 제공한다.

**요청 헤더(Request header)** :
클라이언트가 서버에 요청할 때 이용되는 헤더이다.
클라이언트가 사용하는 언어정보 (languages), 유저 에이전트 (user agent) 와 받아들이는 미디어 타입에 대한 정보 (content-type) 등이 포함되어 있다.

**대표적 요청 헤더에는**
> **Host :** 요청하려는 서버 호스트 이름과 포트번호
>
> **User-Agent** : 클라이언트 프로그램 정보 ex) Mozilla/4.0, Windows NT5.1
>
> **Referer** : 현재 페이지로 연결되는 링크가 있던 이전 웹 페이지의 주소
>
> **Accept** : 클라이언트가 처리 가능한 MIME Type 종류 나열
>
> **Accept-Language** : 클라이언트가 지원가능한 언어 나열
>
> **Cookie :** 쿠기 값 key-value로 표현된다. Set-Cookie 헤더와 함께 서버로부터 이전에 전송됐던 저장된 HTTP 쿠키를 포함

Body (본문)
- POST, PUT 요청과 같이 **요청과 함께 전달되는 데이터**를 포함한다.
  - 요청과 함께 전달되는 데이터가 없을 경우 Body가 없을 수도 있다.

<!--
헤더: 호스트의 이름 또는 IP주소, 브라우저의 종류, 쿠키 정보 개발자도구 페이지에 가면 정보가 나와있음
헤더(header) : 사용자 요청 정보
    - 요청 URL, 
    - 요청 PATH,  
    - 요청 브라우저 설정(언어-Accept-Language, 브라우저 종류 - user-agent),  
    - 요청 쪽 IP, 
    - 요청 방식(GET, POST), 
    - 쿠키
바디(body)
     - 요청 쪽 전송 데이터 (POST)
     - 요청 헤더 Content-Type application/x-www-form-urlencoded;
     -요청 바디 : 키=값&키=값
              값 → URL 인코딩(16진수로 전환)
     -요청 헤더: Content-Type: application/json
     -요청 바디: { “키”: “값”, “키”: “값” }
     -->

### 응답 (Response)
서버가 클라이언트로 보내는 메세지.

- Header
  - 응답에 대한 부가적인 정보
    Server (응답)
    서버의 소프트웨어 정보

### Header 항목
Set-Cooke
- 서버측에서 클라이언트에게 세션 쿠키 정보를 설정한다.


Age
- 캐시 응답. max-age 시간 내에서 얼마나 흘렀는지 초단위로 알려준다.
- Ex) max-age= 3600을 설정한 경우, 1분 후 Age: 60이 캐시 응답 헤더에 포함된다.


Cache-Control
- 웹 브라우저나 중간 서버와 같은 클라이언트 캐시에서 데이터의 캐싱 동작을 제어하는데 사용 된다.
- no-store : 클라이언트나 중간 서버에서 데이터를 저장하지 않아야 함을 뜻한다. 보안적인 이유로 민감한 정보가 포힘된 데이터의 경우에 사용한다. 캐시를 사용하지 않음을 뜻한다.
- no-cache : 클라이언트가 데이터를 캐시에 저장하지 않고 매번 서버로부터 다시 요청해야 함을 나타낸다.
  캐시를 사용하기 전에 서버에게 검사를 받고 데이터가 변경되지 않았다면 캐시를 사
  용한다.
- must-revalidate : 캐시 만료 후 최초 조회 시 원 서버에 검증 받아야 한다.


Content-Encoding
- 큰 HTML 문서를 압축해 전송 시간을 줄이기 위해서 사용한다.
- 혹은 허락받지 않은 제 3자가 볼 수 없게 콘텐츠를 암호화하거나 뒤섞어 보내는 목적으로 사용한다.
- 콘텐츠의 포맷과 연관되어있다.
- gzip, compress, defalte, identity와 같은 알고리즘 사용한다.
- 발송하는 쪽에서 콘텐츠에 적용한다.


Content-Type
- 컨텐츠의 미디어 타입, 문자 인코딩


Date
- 메시지가 보내진 날짜와 시간
- Wed, 13 Dec 2023 10:26:25 GMT


Location
- 300번대 응답이나 201 Created 응답일 때 어느 페이지로 이동할지를 알려주는 헤더

- Body (본문)
  서버가 클라이언트에게 응답할 데이터가 존재할 경우 해당 데이터를 담고 있다.

</details>

## 스프링 : 컴포넌트 스캔
<details>

# 컴포넌트스캔
- 스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능.
- 이전까지는 설정 정보에 직접 스프링 빈을 등록, 나열했는데 등록해야 할 빈의 수가 많아지면 일일히 등록하기 번거롭고, 설정 정보도 커지고, 누락 문제도 발생.
- 설정 클래스에서 빈으로 등록하지 않아도 원하는 클래스를 빈으로 등록할 수 있으므로 컴포넌트스캔 기능을 사용하면 설정 코드가 크게 줄어든다.
- 또한 의존 관계를 자동으로 주입하는 @Autowired 기능도 제공한다.

## 1. @Component
- 스프링이 검색해서 빈으로 등록할 수 있으려면 클래스에 @Component 어노테이션을 붙여야 한다.

- @Component 어노테이션에서 빈의 이름을 지정하지 않을 경우, 클래스 이름의 맨 앞글자를 소문자로 바꿔 자체 등록하여 사용한다.

## 2. @ComponentScan 어노테이션으로 스캔 대상 설정 및 제외하기
- @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록하려면 우선 설정 클래스에 @ComponentScan 어노테이션을 적용해야 한다.
- 기존의 설정 클래스와는 다르게 자동으로 스프링 빈을 등록하기 때문에 클래스 내부에 @Bean으로 등록한 클래스가 존재하지 않는다.
- 컴포넌트 스캔은 이름 그대로 @Component 어노테이션이 붙은 클래스를 스캔해 스프링 빈으로 등록한다.

- basePackages에 속성을 등록해 스캔 대상 패키지 목록을 지정한다.
- @ComponentScan (basePackages = {”spring})은 현재 프로젝트내에 존재하는 spring 패키지와 spring 패키지 하위 패키지에 속한 모든 클래스를 스캔 대상으로 설정한다는 의미이다.
- 반면 excludeFilters 속성을 사용하면 스캔할 때 특정 대상을 자동 등록 대상에서 제외할 수 있다.

## 기본 스캔 대상
@Component 어노테이션 뿐만 아니라 @Controller, @Service, @Repository, @Aspect, @Configuration 어노테이션이 붙은 클래스도 스캔 대상에 포함된다.


## 3. 컴포넌트 스캔에 따른 충돌 처리
- 컴포넌트 스캔 기능을 사용해서 자동으로 빈을 등록할 때는 중복된 빈 이름으로 인한 충돌에 주의해야 하는데, 스캔할 때 빈 이름이 같은 경우 수동 등록한 빈이 우선 스캔된다.

## 스프링 : 의존성 자동 주입

의존 대상을 설정 코드에서 직접 주입하기 않고 스프링이 자동으로 의존하는 빈 객체를 주입해주는 기능도 있다. 이를 자동 주입이라 한다.

스프링에서 의존 자동 주입을 설정하려면 @Autowired 애노테이션이나 @Resource 애노테이션을 사용하면 된다. 스프링에서는 주로 **@Autowired**를 많이 사용한다.

**@Autowired 애노테이션을 이용한 의존 자동 주입**
자동 주입 기능을 사용하면 스프링이 알아서 의존 객체를 찾아서 주입한다.

자동 주입 기능을 사용하는 방법은 의존을 주입할 대상에 @Autowired 애노테이션을 붙이기만 하면 된다.

@Autowired 애노테이션을 **필드**나 **Setter 메서드**에 붙이면 스프링은 타입이 일치하는 빈 객체를 찾아서 주입한다.

---

### 일치하는 빈이 없는 경우
- @Autowired 애노테이션을 적용한 대상에 일치하는 빈이 없으면 UnsatisfiedDependencyException이 발생한다.

### @Autowired 애노테이션을 붙인 주입 대상에 일치하는 빈이 두 개 이상인 경우
- @Qualifier는 추가 구분자를 넣어주는 방식이다.
  -   빈 등록과 주입시 파라미터에 Qaulifier 이름을 추가하여 검색을 시도한다.

- @Primary는 동일 타입 빈이 매칭되면 해당 빈을 우선 주입하라는 뜻이다.

- @Primary와 @Qualifier가 겹치면 @Qualifier가 우선순위를 가져간다.




- 컴포넌트 스캔 기능을 이용할 때 다른 패키지에 같은 이름의 클래스가 존재할 경우
  @ComponentScan (basePackages = {”spring”, “spring2”}로 스캔 범위를 설정하고 스프링 컨테이너를 생성하면 spring2 패키지에 있는 MemberRefisterService 클래스를 빈으로 등록할 때, 빈 이름인 memberRefisterService 가 spring 패키지에 있는 MemberRefisterService 클래스의 빈과 타입이 다르다고 충돌이 일어난다.

## 4. 컴포넌트 스캔과 자동 의존 주입
@Autowired
- 생성자에 @Autowired 어노테이션을 지정하면, 스프링컨테이너가 자동으로 해당 스프링을 찾아 주입한다.
- 이 때, 기본 조회 전략은 타입이 같은 클래스의 빈 또는 해당 타입의 후손 클래스의 빈을 찾아서 주입하는 것니다.
  - getBean(MemberRepository.class)와 동일하다고 이해하면 된다.
  - 같은 타입이 여러 개 있는 경우 충돌 발생
- 생성 파라메터가 많아도 다 찾아서 자동으로 주입한다.


</details>