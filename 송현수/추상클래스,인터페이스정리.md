## 추상 클래스란
- 구체적이지 않은 추상적인(abstract) 데이트럴 담고 있는 클래스
- 따라서 인스턴스화 불가 
- 선언시 abstract 키워드 사용
- 추상화 
    - 추상화란 자동차를 움직임에 있어 조작원리를 설명하는것이 아닌  
    조작 방법만을 설명해 개념만을 알려주는것

- 선언부와 구현부  
    - 선언부란 메소드만 정의하고 구현체를 만들지 않은 상태 (간의 설계도?)  
    - 구현부란 선언된 메소드의 실제 내용을 채우는 부분이다  (구체화된 설계도)

- 추상클래스 정의 
    - 하나 이상의 추상 메소드를 포함한 클래스
    ```java
    public abstarct class heape {
        private String type;

        public shape(String type){
            this.type = type;
        }
        
        public abstract void draw(); // 추상 메소드
    }
    
    ```
- 추상 클래스안의 메소드를 구현화 하지 않는 이유??
- 추상 클래스를 상속 받는 자식 클래스에 따라 메서드 내용이 달라질 수 있기 때문이다.
    - 메소드 재정의 하여 구현하기 위함이다.

- 추상 클래스 생성자
    - 추상 클래스는 클래스지만 인스턴스화 할수 없다.
    - 인스턴스를 할수는 없지만 상속을 통해 자식 클래스를 인스턴스화 하여 사용한다.

    ```java
    abstract class 동물 { // 동물 추상 클래스
    }

    class 고양이 extends 동물 { // 추상 클래스 상속
    }

    class 강아지 extends 동물 { // 추상 클래스 상속
    }

    public class Main {
        public static void main(String[] args) {
            // 추상 클래스를 상속한 자식 클래스를 객체로 초기화
            고양이 c = new 고양이(); 
            강아지 d = new 강아지();
        }
    }
    ```

- 추상 클래스는 생성자를 만들지는 못하지만 기본 생성자 슈퍼는 있다고 한다.

- 추상 클래스를 쓰는 이유 

    ```
        - 공통으로 중복 코드 제거 : 공통 필드,메소드를 묶어 사용할수 있다.
        - 코드 재사용성 증가 : 공통적으로 들어가는 코드이기 때문에 재사용성이 증가한다.
    ```

    - 구현의 강제성을 통한 기능 보장
        - 상속을 통해 메소드에서 인스턴스화 하여 사용한다면. 
            - 상속을 통해 전달 받은 추상 메소드는 하나라도 빠질 경우에 컴파일 에러가 나온다.  
            하지만 일반 클래스로 상속을 받는다면 컴파일 에러가아닌 런타임 에러가 생겨 찾기가 더힘들어진다.  
            따라서 추상 클래스를 쓰는것이 구조적 안정성이 더 올라간다.
    
- 추상 클래스란 정리
    - 투 룸에서 공통 기능들을 구현하고 다른 환경에 따라 상황에 맞게 변화를 주어  
    유연하게 집을 짓는 설계도 이다          


- 인터 페이스 이해
    - 인터페이스는 설계하고 조금 더 유연한 프로그램을 만들기 위한 기법이다.  
        말하자면 객체 상관없이 원하는 메소드만 호출하고 결과 값을 받는 상호작용 기능이다.
    
- 인터 페이스의 정의
    - 추상 메서드의 집합 
    - 필드 선언은 가능하나 상수로만 정의할수 있다.
    - 인터 페이스 클래스는 abstract , public static final 예약어는 생략이 가능하다.  
        컴파일시 자동으로 추가해준다.

    - 인터페이스 구현
        - 인터페이스 또한 추상클래스 집합 이기에 상속을 통해 구현 되어야 한다.
        - 인터페이스를 구현 할려면  implements 키워드를 사용해야 한다.
        - 인터페이스의 큰 특징은 다중 상속이 가능하다.
        - 상속과 인터페이스 를 동시에 받을수 있다.

        ```java
        public interface 움직인다{
            /*public abstract 생략가능 */ void 움직인다();
        }
        ```
        ```java
        public class 사람 extends 운동 implements 운직인다.{
            
            @Override
            public void 운동(){
                System.out.println("움직여서 운동을 한다.")
            }
        }
         ```

        - 인터페이스를 일부 구현 할수있다.  
        구현할경우 abstract 를 붙여서 추상 클래스로 선언해야 한다.

        ```java
        interface MyInterface {
            void methodA();
            void methodB();
            void methodC();
        }

        abstract class MyAbstractClass implements MyInterface {
            public void methodA() {
                // methodA의 구현 내용
                System.out.println("구현된 methodA");
            }

            // methodB와 methodC는 추상 메서드로 남겨짐
            // 따라서 이 클래스를 상속받는 하위 클래스에서 구현 필요
            // abstract 키워드가 붙어 추상 메서드임을 나타냄
            abstract void methodB();
            abstract void methodC();
        }

        class MyClass extends MyAbstractClass {
            public void methodB() {
                // methodB의 구현 내용
                System.out.println("구현된 methodB");
            }

            public void methodC() {
                // methodC의 구현 내용
                System.out.println("구현된 methodC");
            }
        }
        ```

    - ## 인터페이스 자체 상속 ##
    
        - 인터페이스 자체를 확장 할때에는 extends 를 통해 인터페이스를 상속하면 된다.
        - 인터페이스는 클래스와 달리 다중 상속이 가능하다. (구현체가 없어 충돌이 없다.)
        - 인터페이스 또한 클래스 상속처럼 조상 클래스에 정의된 멤버를 모두 상속받는다.
        - ### 필드의 경우 기본적으로 static(메모리) 이기 때문에 구현체를 다라가지 않게 된다. (독립 상수) ###
        - 인터페이스에 클래스 상속하는 행위는 불가능하다. 인터페이스는 클래스와 달리 Object 클래스가 최고 조상이 아니기 떄문이다.

    ```
    [인터페이스의 extends는 상속이 아니다.]
    인터페이스는 하나의 타입이나 규격일 뿐이지 그 자체가 하나의 객체가 되는 것이 아니다.
    인터페이스의 상속은 규격이나 스펙 기능의 선언을 물려받는 것이다.

    ```

    - 인터페이스 상수 필드 상속 관계
        - 클래스의 상속일 경우 클래스 필드 멤버끼리 상속되어 덮어 씌워지지만,  
        인터페이스의 필드들은 모두 상수(final) 이기에, 서로 상속을 해도 독립적으로 사용된다.
    
    ```java
    interface MyInterface {
    int INTERFACE_FIELD = 5;  // 상수 (final)
    }

    class MyBaseClass {
        int BASE_FIELD = 10;
    }

    class MyClass extends MyBaseClass implements MyInterface {
        public void printFields() {
            System.out.println("인터페이스 필드: " + MyInterface.INTERFACE_FIELD);
            System.out.println("기본 클래스 필드: " + BASE_FIELD);
        }
    }
    ```

    - 인터페이스 구현 메소드 자바8이상버전
        - 디폴트 메소드,스태틱 메소드
        - 스트림,람다표현식 기능 추가

    - 디폴트(default) 메소드 
        - 디폴트 메서드는 인터페이스 안에서 default 를 붙여 일반 메서드처럼 구현부 {...} 가 있어야한다.
        - 자식 클래스(구현체)에서 default 메소드를 오버라이딩 하여 재정의 가능하다.
        - 주의사항 인터페이스는 Object 클래스의 상속을 받지 않기 떄문에   
        Object 클래스 기능(equals,hasCode)는 제공할 수 없다. 따라서 구현체가 직접 재정의 해야한다.
        - 디폴트 메소드는 다중 상속 문제가 있다. 
            - 디폴트 메소드는 구현체가 있기 때문에 신경쓰지 않으면 충돌이 발생한다.
            - 인터페이스의 디폴트 메서드와 부모 클래스 메서드를 동시에 상속 받았을 경우  
            디폴트 메서드 안에있는 구현체는 무시된다.
        - 디폴트 메소드 또한 슈퍼(기본 생성자가 존재한다.)

    - static 메소드
        - 인스턴스 생성과 상관없이 인터페이스 타입으로 접근해 사용할 수 있는 메서드
        - 일반 클래스의 static 메소드와 다를 바 없다.

    - private 메소드  
        - 자바9 버전에 추가된 메서드
        - private 메소드도 구현부를 가져야한다.
        - private 메소드는 인터페이스 내부에서만 돌아가는 코드이다.
        - 따라서 인터페이스 내부에서 private 메소드를 호출할때, default 메소드 내부에서 호출해야 하며,  
        만일 private static 키워드를 붙인 메소드는 static 메소드에서만 호출이 가능하다.
    
    - 인터페이스 다향성
        - 부모클래스 타입으로 자식 클래스 타입을 포함 시킬수 있다는 다형성의 법칙도 인터페이스에 고대로 적용이 가능하다.

        - 클래스가 여러 개의 인터페이스를 구현하게 되면, 결과적으로 변수의 타입으로도 다양하게 쓰일 수 있다는 것을 의미하게 된다.

- 의존성을 제거 (decoupling)
    - 의존성이란 객체 지햐ㅑㅇ 설계에 아주 중요한 개념으로 객체가 어떻게 이어지는지 나타내는 것이다.
    - 코드 설계를 구현체 클래스로 하게 되면 객체간의 강한 의존성이 생기게 되어 만일 코드 변경이 필요하게 된다면 이것 저것 여러가지 변경이 필요해질 수 도 있다. 따라서 클래스 간의 관계를 구성할때 그 관계를 느슨하게 하는 것이 중요하다.

    따라서 그 관계를 상속이 아닌 인터페이스로 확장 시킨다면 객체관의 관계를 조금더 느슨하게 만들어 변화에 강한 클래스를 만들수 있다.  
    
    (상속을 받으면 추상 메서드를 다 만들어야 하지만 인터페이스는 꼭 다 구현해야 할 필요는 없기때문에 변화에 강하다)