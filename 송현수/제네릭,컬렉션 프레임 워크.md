<<<<<<< HEAD
 # 제네릭(Generics)이란

    자바에서 제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 저장하는 기법을 의미한다.   
    객체별로 다른 타입의 자료가 저장될 수 있도록 한다.

    자바에서 배열과 함께 자주 쓰이는 자료형이 리스트 이다.   
    다음과 같이 클래스 선언문에 꺾쇠 괄호 <> 로 표현단다.

``` java
ArrayList<String> list = new ArryList<>();
```
<> 가 바로 제네릭이다. 
코드를 보면 꺾쇠 안에 타입명을 기재한다. 
그렇게 하면 리스트 타입은 String 타입으로 지정되어 문자열만 들어갈수있다.

제네릭은 타입을 지정하듯이 리스트 자료형 같은 컬렉션 클래스나 메소드에서 사용할 데이터 타입을   
파라미터주듯이 외부에서 지정하는 타입으로 변환 한 기능이다.

우리가 탑입을 선언하지 않을경우 제네릭은 Object 타입을 쓴다.

## 제네릭 타입 매개변수 ##

- 제네릭 타입은 <> 꺾쇠 괄호 키워드를 사용한다.
- 꺽쇠 괄호 안에 식별자 기호를 지정함으로써 파라미터화 할수있다. 마치 매개변수를 받아 사용하는것과 유사하다. 
- 제네릭에서는 타입 매개변수/타입변수 라고 부른다.
    ```
    List<T> 타입 매개변수
    List<String> stringList = new ArrayList<String>(); 매개변수화된 타입
    ```
### 타입 파라미터 정의 ###
- 타입 매개변수는 **제네릭을 이용한 클래스나 메소드를 설계** 할 떄 사용된다.

    ```java
    class FruitBox<T> {
        List<T> fruits = new ArrayList<>();

        public void add(T fruit) {
            fruits.add(fruit);
        }
    }
    ```
    - 이 코드는 제네릭을 감미한 클래스를 정의한 코드이다.
    - 클래스명 옆에 <T> 기호로 제네릭을 사용하였다.
    - 클래스 내부에서 식별자 기호로 T 를 클래스 필드와, 메소드의 매개변수의 타입으로 지정했다.
    ```java
    // 제네릭 타입 매개변수에 정수 타입을 할당
    FruitBox<Integer> intBox = new FruitBox<>(); 

    // 제네릭 타입 매개변수에 실수 타입을 할당
    FruitBox<Double> intBox = new FruitBox<>(); 

    // 제네릭 타입 매개변수에 문자열 타입을 할당
    FruitBox<String> intBox = new FruitBox<>(); 

    // 클래스도 넣어줄 수 있다. (Apple 클래스가 있다고 가정)
    FruitBox<Apple> intBox = new FruitBox<Apple>();

    ```
    - 제네릭 클래스에 인스턴스화 , 마치 파라미터를 지정하여 보내는 것 처럼   
    생성 코드에서 꺾쇠 괄호 안에 지정하고 싶은 타입명을 할당해주면,   
    제네릭 클래스 선언문 부분에 T 타입이 저장된 타입으로 모두 변환되어    
    클래스의 타입이 지정되게 되는 것이다.

    제네릭 타입 전파가 되어 <T> 부분에 실행부 타입을 받아와   
    내부에서 T 타입으로 지정된 멤버들에게 전파하여 타입이 구체적으로 설정 되는 것이다.    
    이를 구체화 라고 한다.


    ## 타입 파라미터 생략 ##

    ```java
    // 에전 방식
    FruitBox<Apple> intBox = new FruitBox<Apple>();

    // jdk 1.7 이후 방식
    FuritBox<Apple> intBox = new FruitBox<>();
    ```
    - 코드를 보면 jdk 1.7 이전 버전에서는 꺾쇠 괄호 안에 타입 매개변수를 작성해야 했지만
    - jdk 1.7 이후 에서는 new 생성자 부분의 제네릭 타입을 생략할 수 있게 되었다.

    ## 타입 파라미터 할당 가능 타입 ##
    - 제네릭에서는 사용할수 있는 타입이 정해져있다.
    - 사용 가능한 타입은 기본 타입을 제외한 참조 타입이다.
    - 기본 타입을 사용할 경우 유연성과 편리성이 떨어져 사용하지 않는다.

    ## 복수 타입 파라미터 ## 
    - 제네릭은 반드시 한개만 사용하라는 법은 없다. 한개 이상의 타입이 필요한 경우 얼마든지 만들수 있다.
    - <T,U,.,.,.> <,>꺾쇠 괄호 안에 쉽표를 사용하여 복수형태로 만들수 있다. 
    - 단 사용할떄에는 제네릭 갯수만큼 만들어 주어야 한다. 

    ```java
    import java.util.ArrayList;
    import java.util.List;

    class Apple {}
    class Banana {}

    class FruitBox<T, U> {
        List<T> apples = new ArrayList<>();
        List<U> bananas = new ArrayList<>();

        public void add(T apple, U banana) {
            apples.add(apple);
            bananas.add(banana);
        }
    }

    public class Main {
        public static void main(String[] args) {
            // 복수 제네릭 타입
            FruitBox<Apple, Banana> box = new FruitBox<>();
            box.add(new Apple(), new Banana());
            box.add(new Apple(), new Banana());
        }
    }

    복수형으로 2개를 만들었기에 두개를 선언해주어야 한다.
    ```

    ## 중첩 타입 파라미터 ##
    제네릭 객체를 제네릭 타입 파라미터로 받는 형식도 표현할 수 있다.
    - ArrayList 자체도 하나의 타입으로써 제네릭 타입 파라미터가 될수 있기 때문에 이렇게 중첩 형식으로 사용할 수 있는 것이다.
    ```java
    public static void main(String[] args) {
        // LinkedList<String>을 원소로서 저장하는 ArrayList
        ArrayList<LinkedList<String>> list = new ArrayList<LinkedList<String>>();

        LinkedList<String> node1 = new LinkedList<>();
        node1.add("aa");
        node1.add("bb");

        LinkedList<String> node2 = new LinkedList<>();
        node2.add("11");
        node2.add("22");

        list.add(node1);
        list.add(node2);
        System.out.println(list);
    }

    결과값
    [[aa,bb]] , [[11,22]]
    ```
    ## 타입 파라미터 기호 네이밍 ##
    

    | 타입| 설명|
    | --- | --- |
    | < T > | 타입|
    | < E > | 요소(Element),  예를 들어 List|
    | < K > | 키(Key) , 예를 들어 Map< K,V >|
    | < v > | 리턴 값 또는 매핑된 값 (Variable)|
    | < N > | 숫자 (Number) |
    | < S,U,V > | 2번재3,번째4번째에 선언된 타입|

    ## 제네릭 사용 이유와 이점 
    
    ### 1) 컴파일 타임에 타입 검사를 통해 예외 방지 ###
    
    자바에서 제네릭은 Object 타입으로 사용되어 있다. 하지만 Object 타입은 객체를 다시 타입 변환을 반드시 해야 한다.
    - 하지만 제네릭을 이용하면 실수를 미연에 방지할수 있다.  
    이유는 코드를 실행 하기전 컴파일 타임에 미리 에러를 찾아 알려주기 떄문이다.  
    또한 클래스나 메서드를 정의할때 타입 파라미터로 객체의 서브 타입을 지정해줌으로써,  
    잘못된 타입이 사용될 문제점을 컴파일 과정에서 제거하여 개발에 용이하게 해준다 (유연성)
    ### 2) 불필요한 캐스팅을 없애 성능 향상 ###
    - 제네릭은 미리 타입을 지정& 제한해 놓기 때문에 형 변환의 번거로움을 줄일 수 있으며,  
    타입 검사에 들어가 메모리를 줄일수 있고 가독성도 좋아진다.

    ## 제네릭 사용 주의사항
    
    ### 1) 제네릭 타입의 객체는 생성 불가
    제네릭 타입 자체로 타입을 지정하여 객체를 생성하는 것은 불가능하다.   
    즉 new 연산자 뒤에 제네릭 타입 파라미터가 올수 없다.
    
    ### 2) static멤버에 제네릭 타입이 올수 없음
    ```
    컴파일러는 제네릭 코드를 일반적인(non-generic) 코드로 변환하는 과정에서 제네릭 타입 정보를 제거합니다.   
    제네릭 클래스 또는 메서드의 타입 매개변수는 실제 사용되는 타입으로 치환되거나, 타입으로부터 자동으로 변환됩니다.
    ```
    - 아래 처럼 static 변수의 데이터 타입으로 제네릭 타입 파라미터가 올수는 없다.  
    static 멤버는 클래스가 동일하게 공유하는 변수로서 제네릭 객체가 생성되기전   
    이미 자료 타입이 정해져 있어야 하기 때문이다. 논리적인 오류 실행 순서 간의 오류
     
     ### 3) 제네릭으로 배열 선언 주의점

     기본적으로 제네릭 클래스 자체를 배열로 만들 수는 없다.   
     하지만 제네릭 타입의 배열 선언은 허용된다.
     ```java
     class Sample<T> { 
    }

    public class Main {
        public static void main(String[] args) {
            Sample<Integer>[] arr1 = new Sample<>[10];
        }
    }

    불가능
     ```

     ```java
     class Sample<T> { 
    }

    public class Main {
        public static void main(String[] args) {
            // new Sample<Integer>() 인스턴스만 저장하는 배열을 나타냄
            Sample<Integer>[] arr2 = new Sample[10]; 
            
            // 제네릭 타입을 생략해도 위에서 이미 정의했기 때문에 Integer 가 자동으로 추론됨
            arr2[0] = new Sample<Integer>(); 
            arr2[1] = new Sample<>();
            
            // ! Integer가 아닌 타입은 저장 불가능
            arr2[2] = new Sample<String>();
        }
    }

    가능 
     ```

    ## 제네릭 와일드 카드 ##
    
    1) <?>: 물음표 와일드 카드
        모든 타입을 대표하는 와일드 카드입니다. 제네릭 클래스 또는 메서드에서 어떤 유형의 인자가 전달되든 상관하지 않을 때 사용됩니다.

    2) <? extends T>: 상한 와일드 카드
        T 타입이거나 T의 하위 클래스를 나타내는 와일드 카드입니다. 보통 읽기만을 위한 용도로 사용되며, 해당 타입의 요소를 가져올 수 있지만 추가는 불가능합니다.

    3) <? super T>: 하한 와일드 카드
        T 타입이거나 T의 상위 클래스를 나타내는 와일드 카드입니다. 주로 쓰기를 위한 용도로 사용되며, 해당 타입의 요소를 추가할 수 있지만 가져오기는 보장되지 않습니다.


        출처: https://inpa.tistory.com/entry/JAVA-☕-제네릭Generics-개념-문법-정복하기#타입_파라미터_생략 [Inpa Dev 👨‍💻:티스토리]

    # java컬렉션 프레임 워크 란? #
    컬렉션 프레임워크란 그냥 자료 구조(Data Structure) 종류의 형태들을 자바 클래스로 구현한 모음집 이라고 보면 된다.

    ## 컬렉션 프레임워크 장점 ##
    
    - 인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화되어 있기 때문에, 사용법을 익히기에도 편리하고 재사용성이 높다.
    - 데이터 구조 및 알고리즘의 고성능 구현을 제공하여 프로그램의 성능과 품질을 향상시킨다.
    - 관련 없는 API 간의 상호 운용성을 제공한다. (상위 인터페이스 타입으로 업캐스팅하여 사용)
    - 이미 구현되어있는 API를 사용하면 되기에, 새로운 API를 익히고 설계하는 시간이 줄어든다.
    - 소프트웨어 재사용을 촉진한다.   
    만일 자바에서 지원하지 않는 새로운 자료구조가 필요하다면, 컬렉션들을 재활용하여 좁합하여 새로운 알고리즘을 만들어낼 수 있다.

    ``` 
    TIP

    컬렉션 프레임워크에 저장할 수 있는 데이터는 오로지 객체(Object) 뿐이다. 즉, int형이나 double형 같은 자바의 primitive 타입은 적재를 못한다는 말이다. 따라서 primitive 타입을 wrapper 타입으로 변환하여 Integer 객체나 Double 객체로 박싱(Boxing)하여 저장하여야 한다. 또한 객체를 담는 다는 것은 곧 주소값을 담는다는 것이니, null도 저장이 가능하다.
    ```

    ## 컬렉션 프레임 워크 종류
    - Collection 인터페이스
        -List, Set 인터페이스를 구현 클래스는 Collection에 상속 되어있다.
    - Mop 인터페이스 
        - Mop 인터페이스는 컬렉션들은 두개의 데이터를 묶어 한쌍으로 다루기 떄문에   
        Collection 인터페이스와 따로 분리되어 있다. 

    ```
    TIP

    대부분의 컬렉션 클래스들은 List, Set , Map 중의 하나를 구현하고 있으며, 구현한 인터페이스의 이름이 클래스 이름에 포함되는 특징이 있다.
    (ArrayList, HashSet, HashMap ... 등)
    ```

    ## Iterable 인터페이스 ##
    - 컬렉션 인터페이스들의 가장 최상위 인터페이스
    - 컬렉션들은 이터레이터 객체를 다루게 되는데 이터레이터 객체를 관리하는 인터페이스로 보면 된다.

    | 메서드 | 설명 |
    | --- | --- |   
    | default void for Each(Consumer<? super T> action) | 함수형 프로그래밍 전용 루프 메서드|
    |Iterator<T>iterator()|컬렉션에서 이터레이터를 구현|
    |default SPliterator<T>splierator()|파이프라이닝 관련 메소드|

    ```
    TIP

    참고로 Map은 iterable 인터페이스를 상속받지 않기 때문이 iterator()와 spliterator()는 Map 컬렉션에 구현이 되어 있지 않다. 따라서 직접적으로 Map 컬렉션을 순회할수는 없고 스트림(Stream)을 사용하거나 간접적으로 키를 Collection으로 반환하여 루프문으로 순회하는 식을 이용한다.
    ```

    ## Collection 인터페이스 ##
    - List,set,Queue에 상속을 하는 실질적인 최상위 컬렉션 타입
    - 업 캐스팅으로 다양한 종류의 컬렉션 자료형을 받아 자료를 삽입하거나 삭제, 탐색 기능을 할 수 있다. (다형성)

    ## List 인터페이스 ##
    - 저장 순서가 유지되는 컬렉션
    - 같은 요소 중복 저장 허용
    - 배열과 마찬가지로 index 요소 접근
    - 자료형 크기에 따라 늘어나거나 줄어들수 있다.
    - 요소 사이에 빈공간을 허용하지 않아 삭제시 주의해야한다.

    ## ArrayList 클래스 ##

    - 배열을 이용하여 만든 리스트
    - 데이터의 저장 순서가 유지되고 중복을 허용
    - 데이터량에 따라 공간이 자동으로 늘어나거나 줄어듬
    - 조회가 빠르다.
    - 중간범위 삭입 삭제가 느리다. 단 순서대로 삭제하는 경우는 빠르다.

    ## LinkedList 클래스 ##
    - 객체를 연결하여 리스트 처럼 만든 컬렉션 
    - 데이터 중간 삽입, 삭제가 빠르다.
    - 임의 요소에 대한 접근성은 좋지않다.
    - linkedList는 리스트 용도 이외에도, 스택,큐,트리 등의 자료구조의 근간이 된다.

    ## Vector 클래스 ##
    - ArrayList의 구형버전
    - ArrayList와의 차이는 모든 메소드가 동기화 되어있어 Thread-SaFe하다는 점이다.
    - 구버전 자바와의 호환성을 위해 남겨두었지만 잘 쓰지 않는다.

    ## Stack 클래스 ##
    - 후입선출 자료 구조
    - 마지막에 들어온 원소가 처음으로 나간다.
    - 들어올때는 push(푸쉬), 나갈대는 pop(풀)이라는 용어를 사용
    - Statk은 Vector를 상속하기 때문에 문제점이 많아 잘 안쓴다. 대신 ArrayDeque 사용한다.

    ## Queue 인터페이스
    - 선입선출 구조
    - 처음 들어온 원소가 가장 먼저 나간다.
    - 자바에서 Queue 는 인터페이스이고 필요에따라 큐 컬렉션을 골라 사용할 수 있다.

    ## PriorityQueue 클래스##
    - 우선 순위를 가지는 큐
    - 일반적인 큐와는 조금 다르게, 원소에 우선순위!를 부여하여 순위가 높은 순으로 정렬된다.
    - 수행할 작업이 여러 개 있고 시간이 제한되어 있을 때 우선 순위가 높은 것부터 수행할때 쓰인다.
    - 우선순위 큐에 저장할 객체는 필수적으로 Comparable 인터페이스를 구현한다.
    - 저장공간은 배열을 사용하며, 각 요소를 힙 형태로 저장한다.
    - null 저장 불가능 

    ## Deque 인터페이스 ##
    - Deque는 양쪽으로 넣고 빼는 것이 가능한 큐를 말한다.
    - 스택과 큐를 하나로 합쳐놓은 것 같으며 스택으로 사용할 수도 있고 큐로도 사용할 수 있다.
    - Deque의 조상은 Queue이며, 구현체로 ArrayDeque와 LinkedList 등이 있다.

    ## ArrayDeque 클래스 ##
    - 스택으로 사용할 때 Stack 클래스보다 빠르며, 대기열로 사용할 때는 LinkedList보다 빠르다.
    - 사이즈에 제한이 없다.
    - null 요소는 저장되지 않는다.

    ## LinkedList 클래스 ##

    - LinkedList는 Lisk 인터페이스와 Queue 인터페이스를 동시에 상속받고 있기 때문에, 스택/ 큐 로서도 으용이 가능하다.
    - 실제로 LInkedList 클래스에 큐 동작과 관련된 메서드를 지원한다.(push,pop,pall,peek,offer 등)

    ## Set 인터페이스 ##
    - 데이터의 중복을 허용하지 않고 순서를 유지하는 않는 데이터의 집합 리스트
    - index 가 존재하지 않는다 
    - 중복 저장 불가능 ,null 값도 하나만 저장 가능

    ## HashSet 클래스 ##
    - 배열과 연결 노드를 결합한 자료 구조
    - 가장 빠른 임의 검색 접근속도를 가진다.
    - 추가, 삭제, 검색, 접근성이 모두 뛰어나다.
    - 대신 순서를 전혀 예측할 수 없다.

    ## LinkedHashSet 클래스 ##
    - 순서를 가지는 Set 자료 
    - 추가된 순서 또는 최근에 접근한 순서대로 접근 가능
    - 중복을 제거하는 동시에 저장한 순서를 유지하고 싶다면,HashSet 대신 LinkedHashSet을 써야한다.
    
    ## TreeSet 클래스 ##
    - 이진 검색 트리 자료구조의 형태로 데이터 저장
    - 중복 x , 순서 x 
    - 대신 데이터를 정렬하여 저장하고 있다는 특징이 있다.
    - 정렬, 검색, 범위검색에 높은 성능을 뽐낸다.

    ## EnumSet 추상 클래스 ## 
    - Enum 클래스와 함께 동작하는 Set 컬렉션이다.
    - 중복 되지 않은 상수 그룹을 나타낸다.
    - 산술 비트연산을 사용하여 구현되므로 HashSet 보다 훨씬 빠르고,작은 메모리를 사용한다.
    - 단, enum 타입의 요소값만 저장할수 있고, 모든 요소들은 동일한 enum 객체에 소속되어야 한다.
    - EnumSet은 추상 클래스이고 이를 상속한 RegularEnumSet 혹은 JumboEnumSet 객체를 사용하게 된다.

    ## Map 인터페이스 ##
    - 키(Key) 와 값(value)의 쌍으로 연관지어 이루어진 데이터의 집합
    - 값(Value) 은 중복되서 자장할순 있지만 키(Key)는 해당 Map에서 고유해야만 한다.
    - 만일 기존 데이터와 중복된 키와 값을 저장하면 기존값은 덮어쓰여 사라진다.
    - 저장 순서가 유지되지 않는다.

    ## Map.Entry 인터페이스 ##
    - Map.Entry 인터페이스는 Map 인터페이스 안에 있는 내부 인터페이스 이다.
    - Map 에 저장되는 Key- value 쌍의 Node 내부 클래스가 이를 구현하고 있다.
    - Map 자료구조를 보다 객체지향적인 설계를 하도록 유도하기 위한 것이다.

    ## HashMap 클래스 ##
    - Hashtable을 보완한 컬렉션
    - 배열과 연결이 결합된 Hashing형태로, 키와값을 묶어 하나의 데이터로 저장한다.
    - 중복을 허용하지 않고 순서를 보장하지 않는다.
    - 키와 값으로 null이 허용된다.
    - 추가, 삭제, 검색, 접근성이 모두 뛰어나다.
    - HashMap은 비동기로 작동하기 떄문에 멀티 쓰레드 환경에서는 어울리지않는다.   
    대신(ConcurrentHashMap을 사용한다)

    ## LinkedHashMap 클래스 ##
    - HashMap을 상속하기 떄문에 흡사하지만 Entry들이 연결 리스트를 구성하여 데이터의 순서를 보장한다.
    - 일반적으로 Map 자료구조는 순서를 가지지 않지만, LinkedHashMap은 들어온 순서대로 순서를 가진다.

    ## TreeMap 클래스 ##
    - 이진법 검색 트리의 형태로 키와 값의 쌍으로 이루어진 데이터만을 저장 (TreeSet과 비슷하다.)
    - TreeMap은 SortedMap 인터페이스를 구현하고 있어 Key 값을 기준으로 정렬되는 특직을 가지고 있다.
    - 정렬된 수서로 키/값 쌍을 저장하므로 빠른검색 가능
    - 단 키와 값을 저장하는 동시에 정렬을 행하기 떄문에 저장속도가 느리다.
    - 정렬되는 순서는 숫자-> 대문자 -> 소문자 -> 한글 순이다.

    ## HashTable 클래스 ##
    - 자바 초기버전에 나온 레거시 클래스
    - Key를 톡정 해서 함수를 통해 ㅎ해상한 후 나온 결과를 배열의 인덱스로 사용하여  Value 찾는 방식으로 동작한다.
    - HashMap 보다는 느리지만 동기화가 기본 지원된다.
    - 키와 값으로 null이 허용 불가

    ## Properties 클래스 ##
    - Properties (String, String) 의 형태로 저장하는 단순화된 Key-Value 컬렉션
    - 주로 애플리케이션의 환경 설정과 관련된 속성 파일인.propreties를 설정하는데 사용된다.

    # 컬렉션 프레임워크 선택 시점
    - 종류도 많고 똑같은 자료구조 이지만 각 쓰임새와 특징에 따라 나누니 정리하기 까다롭다.
    
    ## 간단 정리 ##
    ArrayList
    - 리스트 자료구조를 사용한다면 기본 선택
    - 임의의 요소에 대한 접근성이 뛰어남
    - 순차적인 추가/삭제 제일빠름
    - 요소의 추가/ 삭제 불리
    
    LinkedList
    - 요소의 추가/삭제유리
    - 임의의 요소에 대한 접근성이 좋지 않음
    
    HashMap/ HashSet
    - 해시를 이용해 임의의 요소에 대한 추가/ 삭제/ 검색/ 접근성 모두 뛰어남
    - 검색에 최고성능
    
    TreeMap/TreeSet
    - 요소 정렬이 필요할때
    - 검색(특히 범위검색)에 적합
    - 그래도 검색은 HashMap보다 떨어짐
    
    LinkedHashMap/ LinkedHashSet : HashMap과 HashSet에 저장 순서 유지 기능 추가
    
    Queue : 스택(LIFO)/ 큐(FIFO) 자료구조가 필요하면 ArrayDeque 사용
    
    Stack,Hashtable : 가급적 사용 X 
    
    
=======
 # 제네릭(Generics)이란

    자바에서 제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 저장하는 기법을 의미한다.   
    객체별로 다른 타입의 자료가 저장될 수 있도록 한다.

    자바에서 배열과 함께 자주 쓰이는 자료형이 리스트 이다.   
    다음과 같이 클래스 선언문에 꺾쇠 괄호 <> 로 표현단다.

``` java
ArrayList<String> list = new ArryList<>();
```
<> 가 바로 제네릭이다. 
코드를 보면 꺾쇠 안에 타입명을 기재한다. 
그렇게 하면 리스트 타입은 String 타입으로 지정되어 문자열만 들어갈수있다.

제네릭은 타입을 지정하듯이 리스트 자료형 같은 컬렉션 클래스나 메소드에서 사용할 데이터 타입을   
파라미터주듯이 외부에서 지정하는 타입으로 변환 한 기능이다.

우리가 탑입을 선언하지 않을경우 제네릭은 Object 타입을 쓴다.

## 제네릭 타입 매개변수 ##

- 제네릭 타입은 <> 꺾쇠 괄호 키워드를 사용한다.
- 꺽쇠 괄호 안에 식별자 기호를 지정함으로써 파라미터화 할수있다. 마치 매개변수를 받아 사용하는것과 유사하다. 
- 제네릭에서는 타입 매개변수/타입변수 라고 부른다.
    ```
    List<T> 타입 매개변수
    List<String> stringList = new ArrayList<String>(); 매개변수화된 타입
    ```
### 타입 파라미터 정의 ###
- 타입 매개변수는 **제네릭을 이용한 클래스나 메소드를 설계** 할 떄 사용된다.

    ```java
    class FruitBox<T> {
        List<T> fruits = new ArrayList<>();

        public void add(T fruit) {
            fruits.add(fruit);
        }
    }
    ```
    - 이 코드는 제네릭을 감미한 클래스를 정의한 코드이다.
    - 클래스명 옆에 <T> 기호로 제네릭을 사용하였다.
    - 클래스 내부에서 식별자 기호로 T 를 클래스 필드와, 메소드의 매개변수의 타입으로 지정했다.
    ```java
    // 제네릭 타입 매개변수에 정수 타입을 할당
    FruitBox<Integer> intBox = new FruitBox<>(); 

    // 제네릭 타입 매개변수에 실수 타입을 할당
    FruitBox<Double> intBox = new FruitBox<>(); 

    // 제네릭 타입 매개변수에 문자열 타입을 할당
    FruitBox<String> intBox = new FruitBox<>(); 

    // 클래스도 넣어줄 수 있다. (Apple 클래스가 있다고 가정)
    FruitBox<Apple> intBox = new FruitBox<Apple>();

    ```
    - 제네릭 클래스에 인스턴스화 , 마치 파라미터를 지정하여 보내는 것 처럼   
    생성 코드에서 꺾쇠 괄호 안에 지정하고 싶은 타입명을 할당해주면,   
    제네릭 클래스 선언문 부분에 T 타입이 저장된 타입으로 모두 변환되어    
    클래스의 타입이 지정되게 되는 것이다.

    제네릭 타입 전파가 되어 <T> 부분에 실행부 타입을 받아와   
    내부에서 T 타입으로 지정된 멤버들에게 전파하여 타입이 구체적으로 설정 되는 것이다.    
    이를 구체화 라고 한다.


    ## 타입 파라미터 생략 ##

    ```java
    // 에전 방식
    FruitBox<Apple> intBox = new FruitBox<Apple>();

    // jdk 1.7 이후 방식
    FuritBox<Apple> intBox = new FruitBox<>();
    ```
    - 코드를 보면 jdk 1.7 이전 버전에서는 꺾쇠 괄호 안에 타입 매개변수를 작성해야 했지만
    - jdk 1.7 이후 에서는 new 생성자 부분의 제네릭 타입을 생략할 수 있게 되었다.

    ## 타입 파라미터 할당 가능 타입 ##
    - 제네릭에서는 사용할수 있는 타입이 정해져있다.
    - 사용 가능한 타입은 기본 타입을 제외한 참조 타입이다.
    - 기본 타입을 사용할 경우 유연성과 편리성이 떨어져 사용하지 않는다.

    ## 복수 타입 파라미터 ## 
    - 제네릭은 반드시 한개만 사용하라는 법은 없다. 한개 이상의 타입이 필요한 경우 얼마든지 만들수 있다.
    - <T,U,.,.,.> <,>꺾쇠 괄호 안에 쉽표를 사용하여 복수형태로 만들수 있다. 
    - 단 사용할떄에는 제네릭 갯수만큼 만들어 주어야 한다. 

    ```java
    import java.util.ArrayList;
    import java.util.List;

    class Apple {}
    class Banana {}

    class FruitBox<T, U> {
        List<T> apples = new ArrayList<>();
        List<U> bananas = new ArrayList<>();

        public void add(T apple, U banana) {
            apples.add(apple);
            bananas.add(banana);
        }
    }

    public class Main {
        public static void main(String[] args) {
            // 복수 제네릭 타입
            FruitBox<Apple, Banana> box = new FruitBox<>();
            box.add(new Apple(), new Banana());
            box.add(new Apple(), new Banana());
        }
    }

    복수형으로 2개를 만들었기에 두개를 선언해주어야 한다.
    ```

    ## 중첩 타입 파라미터 ##
    제네릭 객체를 제네릭 타입 파라미터로 받는 형식도 표현할 수 있다.
    - ArrayList 자체도 하나의 타입으로써 제네릭 타입 파라미터가 될수 있기 때문에 이렇게 중첩 형식으로 사용할 수 있는 것이다.
    ```java
    public static void main(String[] args) {
        // LinkedList<String>을 원소로서 저장하는 ArrayList
        ArrayList<LinkedList<String>> list = new ArrayList<LinkedList<String>>();

        LinkedList<String> node1 = new LinkedList<>();
        node1.add("aa");
        node1.add("bb");

        LinkedList<String> node2 = new LinkedList<>();
        node2.add("11");
        node2.add("22");

        list.add(node1);
        list.add(node2);
        System.out.println(list);
    }

    결과값
    [[aa,bb]] , [[11,22]]
    ```
    ## 타입 파라미터 기호 네이밍 ##
    

    | 타입| 설명|
    | --- | --- |
    | < T > | 타입|
    | < E > | 요소(Element),  예를 들어 List|
    | < K > | 키(Key) , 예를 들어 Map< K,V >|
    | < v > | 리턴 값 또는 매핑된 값 (Variable)|
    | < N > | 숫자 (Number) |
    | < S,U,V > | 2번재3,번째4번째에 선언된 타입|

    ## 제네릭 사용 이유와 이점 
    
    ### 1) 컴파일 타임에 타입 검사를 통해 예외 방지 ###
    
    자바에서 제네릭은 Object 타입으로 사용되어 있다. 하지만 Object 타입은 객체를 다시 타입 변환을 반드시 해야 한다.
    - 하지만 제네릭을 이용하면 실수를 미연에 방지할수 있다.  
    이유는 코드를 실행 하기전 컴파일 타임에 미리 에러를 찾아 알려주기 떄문이다.  
    또한 클래스나 메서드를 정의할때 타입 파라미터로 객체의 서브 타입을 지정해줌으로써,  
    잘못된 타입이 사용될 문제점을 컴파일 과정에서 제거하여 개발에 용이하게 해준다 (유연성)
    ### 2) 불필요한 캐스팅을 없애 성능 향상 ###
    - 제네릭은 미리 타입을 지정& 제한해 놓기 때문에 형 변환의 번거로움을 줄일 수 있으며,  
    타입 검사에 들어가 메모리를 줄일수 있고 가독성도 좋아진다.

    ## 제네릭 사용 주의사항
    
    ### 1) 제네릭 타입의 객체는 생성 불가
    제네릭 타입 자체로 타입을 지정하여 객체를 생성하는 것은 불가능하다.   
    즉 new 연산자 뒤에 제네릭 타입 파라미터가 올수 없다.
    
    ### 2) static멤버에 제네릭 타입이 올수 없음
    ```
    컴파일러는 제네릭 코드를 일반적인(non-generic) 코드로 변환하는 과정에서 제네릭 타입 정보를 제거합니다.   
    제네릭 클래스 또는 메서드의 타입 매개변수는 실제 사용되는 타입으로 치환되거나, 타입으로부터 자동으로 변환됩니다.
    ```
    - 아래 처럼 static 변수의 데이터 타입으로 제네릭 타입 파라미터가 올수는 없다.  
    static 멤버는 클래스가 동일하게 공유하는 변수로서 제네릭 객체가 생성되기전   
    이미 자료 타입이 정해져 있어야 하기 때문이다. 논리적인 오류 실행 순서 간의 오류
     
     ### 3) 제네릭으로 배열 선언 주의점

     기본적으로 제네릭 클래스 자체를 배열로 만들 수는 없다.   
     하지만 제네릭 타입의 배열 선언은 허용된다.
     ```java
     class Sample<T> { 
    }

    public class Main {
        public static void main(String[] args) {
            Sample<Integer>[] arr1 = new Sample<>[10];
        }
    }

    불가능
     ```

     ```java
     class Sample<T> { 
    }

    public class Main {
        public static void main(String[] args) {
            // new Sample<Integer>() 인스턴스만 저장하는 배열을 나타냄
            Sample<Integer>[] arr2 = new Sample[10]; 
            
            // 제네릭 타입을 생략해도 위에서 이미 정의했기 때문에 Integer 가 자동으로 추론됨
            arr2[0] = new Sample<Integer>(); 
            arr2[1] = new Sample<>();
            
            // ! Integer가 아닌 타입은 저장 불가능
            arr2[2] = new Sample<String>();
        }
    }

    가능 
     ```

    ## 제네릭 와일드 카드 ##
    
    1) <?>: 물음표 와일드 카드
        모든 타입을 대표하는 와일드 카드입니다. 제네릭 클래스 또는 메서드에서 어떤 유형의 인자가 전달되든 상관하지 않을 때 사용됩니다.

    2) <? extends T>: 상한 와일드 카드
        T 타입이거나 T의 하위 클래스를 나타내는 와일드 카드입니다. 보통 읽기만을 위한 용도로 사용되며, 해당 타입의 요소를 가져올 수 있지만 추가는 불가능합니다.

    3) <? super T>: 하한 와일드 카드
        T 타입이거나 T의 상위 클래스를 나타내는 와일드 카드입니다. 주로 쓰기를 위한 용도로 사용되며, 해당 타입의 요소를 추가할 수 있지만 가져오기는 보장되지 않습니다.


        출처: https://inpa.tistory.com/entry/JAVA-☕-제네릭Generics-개념-문법-정복하기#타입_파라미터_생략 [Inpa Dev 👨‍💻:티스토리]

    # java컬렉션 프레임 워크 란? #
    컬렉션 프레임워크란 그냥 자료 구조(Data Structure) 종류의 형태들을 자바 클래스로 구현한 모음집 이라고 보면 된다.

    ## 컬렉션 프레임워크 장점 ##
    
    - 인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화되어 있기 때문에, 사용법을 익히기에도 편리하고 재사용성이 높다.
    - 데이터 구조 및 알고리즘의 고성능 구현을 제공하여 프로그램의 성능과 품질을 향상시킨다.
    - 관련 없는 API 간의 상호 운용성을 제공한다. (상위 인터페이스 타입으로 업캐스팅하여 사용)
    - 이미 구현되어있는 API를 사용하면 되기에, 새로운 API를 익히고 설계하는 시간이 줄어든다.
    - 소프트웨어 재사용을 촉진한다.   
    만일 자바에서 지원하지 않는 새로운 자료구조가 필요하다면, 컬렉션들을 재활용하여 좁합하여 새로운 알고리즘을 만들어낼 수 있다.

    ``` 
    TIP

    컬렉션 프레임워크에 저장할 수 있는 데이터는 오로지 객체(Object) 뿐이다. 즉, int형이나 double형 같은 자바의 primitive 타입은 적재를 못한다는 말이다. 따라서 primitive 타입을 wrapper 타입으로 변환하여 Integer 객체나 Double 객체로 박싱(Boxing)하여 저장하여야 한다. 또한 객체를 담는 다는 것은 곧 주소값을 담는다는 것이니, null도 저장이 가능하다.
    ```

    ## 컬렉션 프레임 워크 종류
    - Collection 인터페이스
        -List, Set 인터페이스를 구현 클래스는 Collection에 상속 되어있다.
    - Mop 인터페이스 
        - Mop 인터페이스는 컬렉션들은 두개의 데이터를 묶어 한쌍으로 다루기 떄문에   
        Collection 인터페이스와 따로 분리되어 있다. 

    ```
    TIP

    대부분의 컬렉션 클래스들은 List, Set , Map 중의 하나를 구현하고 있으며, 구현한 인터페이스의 이름이 클래스 이름에 포함되는 특징이 있다.
    (ArrayList, HashSet, HashMap ... 등)
    ```

    ## Iterable 인터페이스 ##
    - 컬렉션 인터페이스들의 가장 최상위 인터페이스
    - 컬렉션들은 이터레이터 객체를 다루게 되는데 이터레이터 객체를 관리하는 인터페이스로 보면 된다.

    | 메서드 | 설명 |
    | --- | --- |   
    | default void for Each(Consumer<? super T> action) | 함수형 프로그래밍 전용 루프 메서드|
    |Iterator<T>iterator()|컬렉션에서 이터레이터를 구현|
    |default SPliterator<T>splierator()|파이프라이닝 관련 메소드|

    ```
    TIP

    참고로 Map은 iterable 인터페이스를 상속받지 않기 때문이 iterator()와 spliterator()는 Map 컬렉션에 구현이 되어 있지 않다. 따라서 직접적으로 Map 컬렉션을 순회할수는 없고 스트림(Stream)을 사용하거나 간접적으로 키를 Collection으로 반환하여 루프문으로 순회하는 식을 이용한다.
    ```

    ## Collection 인터페이스 ##
    - List,set,Queue에 상속을 하는 실질적인 최상위 컬렉션 타입
    - 업 캐스팅으로 다양한 종류의 컬렉션 자료형을 받아 자료를 삽입하거나 삭제, 탐색 기능을 할 수 있다. (다형성)

    ## List 인터페이스 ##
    - 저장 순서가 유지되는 컬렉션
    - 같은 요소 중복 저장 허용
    - 배열과 마찬가지로 index 요소 접근
    - 자료형 크기에 따라 늘어나거나 줄어들수 있다.
    - 요소 사이에 빈공간을 허용하지 않아 삭제시 주의해야한다.

    ## ArrayList 클래스 ##

    - 배열을 이용하여 만든 리스트
    - 데이터의 저장 순서가 유지되고 중복을 허용
    - 데이터량에 따라 공간이 자동으로 늘어나거나 줄어듬
    - 조회가 빠르다.
    - 중간범위 삭입 삭제가 느리다. 단 순서대로 삭제하는 경우는 빠르다.

    ## LinkedList 클래스 ##
    - 객체를 연결하여 리스트 처럼 만든 컬렉션 
    - 데이터 중간 삽입, 삭제가 빠르다.
    - 임의 요소에 대한 접근성은 좋지않다.
    - linkedList는 리스트 용도 이외에도, 스택,큐,트리 등의 자료구조의 근간이 된다.

    ## Vector 클래스 ##
    - ArrayList의 구형버전
    - ArrayList와의 차이는 모든 메소드가 동기화 되어있어 Thread-SaFe하다는 점이다.
    - 구버전 자바와의 호환성을 위해 남겨두었지만 잘 쓰지 않는다.

    ## Stack 클래스 ##
    - 후입선출 자료 구조
    - 마지막에 들어온 원소가 처음으로 나간다.
    - 들어올때는 push(푸쉬), 나갈대는 pop(풀)이라는 용어를 사용
    - Statk은 Vector를 상속하기 때문에 문제점이 많아 잘 안쓴다. 대신 ArrayDeque 사용한다.

    ## Queue 인터페이스
    - 선입선출 구조
    - 처음 들어온 원소가 가장 먼저 나간다.
    - 자바에서 Queue 는 인터페이스이고 필요에따라 큐 컬렉션을 골라 사용할 수 있다.

    ## PriorityQueue 클래스##
    - 우선 순위를 가지는 큐
    - 일반적인 큐와는 조금 다르게, 원소에 우선순위!를 부여하여 순위가 높은 순으로 정렬된다.
    - 수행할 작업이 여러 개 있고 시간이 제한되어 있을 때 우선 순위가 높은 것부터 수행할때 쓰인다.
    - 우선순위 큐에 저장할 객체는 필수적으로 Comparable 인터페이스를 구현한다.
    - 저장공간은 배열을 사용하며, 각 요소를 힙 형태로 저장한다.
    - null 저장 불가능 

    ## Deque 인터페이스 ##
    - Deque는 양쪽으로 넣고 빼는 것이 가능한 큐를 말한다.
    - 스택과 큐를 하나로 합쳐놓은 것 같으며 스택으로 사용할 수도 있고 큐로도 사용할 수 있다.
    - Deque의 조상은 Queue이며, 구현체로 ArrayDeque와 LinkedList 등이 있다.

    ## ArrayDeque 클래스 ##
    - 스택으로 사용할 때 Stack 클래스보다 빠르며, 대기열로 사용할 때는 LinkedList보다 빠르다.
    - 사이즈에 제한이 없다.
    - null 요소는 저장되지 않는다.

    ## LinkedList 클래스 ##

    - LinkedList는 Lisk 인터페이스와 Queue 인터페이스를 동시에 상속받고 있기 때문에, 스택/ 큐 로서도 으용이 가능하다.
    - 실제로 LInkedList 클래스에 큐 동작과 관련된 메서드를 지원한다.(push,pop,pall,peek,offer 등)

    ## Set 인터페이스 ##
    - 데이터의 중복을 허용하지 않고 순서를 유지하는 않는 데이터의 집합 리스트
    - index 가 존재하지 않는다 
    - 중복 저장 불가능 ,null 값도 하나만 저장 가능

    ## HashSet 클래스 ##
    - 배열과 연결 노드를 결합한 자료 구조
    - 가장 빠른 임의 검색 접근속도를 가진다.
    - 추가, 삭제, 검색, 접근성이 모두 뛰어나다.
    - 대신 순서를 전혀 예측할 수 없다.

    ## LinkedHashSet 클래스 ##
    - 순서를 가지는 Set 자료 
    - 추가된 순서 또는 최근에 접근한 순서대로 접근 가능
    - 중복을 제거하는 동시에 저장한 순서를 유지하고 싶다면,HashSet 대신 LinkedHashSet을 써야한다.
    
    ## TreeSet 클래스 ##
    - 이진 검색 트리 자료구조의 형태로 데이터 저장
    - 중복 x , 순서 x 
    - 대신 데이터를 정렬하여 저장하고 있다는 특징이 있다.
    - 정렬, 검색, 범위검색에 높은 성능을 뽐낸다.

    ## EnumSet 추상 클래스 ## 
    - Enum 클래스와 함께 동작하는 Set 컬렉션이다.
    - 중복 되지 않은 상수 그룹을 나타낸다.
    - 산술 비트연산을 사용하여 구현되므로 HashSet 보다 훨씬 빠르고,작은 메모리를 사용한다.
    - 단, enum 타입의 요소값만 저장할수 있고, 모든 요소들은 동일한 enum 객체에 소속되어야 한다.
    - EnumSet은 추상 클래스이고 이를 상속한 RegularEnumSet 혹은 JumboEnumSet 객체를 사용하게 된다.

    ## Map 인터페이스 ##
    - 키(Key) 와 값(value)의 쌍으로 연관지어 이루어진 데이터의 집합
    - 값(Value) 은 중복되서 자장할순 있지만 키(Key)는 해당 Map에서 고유해야만 한다.
    - 만일 기존 데이터와 중복된 키와 값을 저장하면 기존값은 덮어쓰여 사라진다.
    - 저장 순서가 유지되지 않는다.

    ## Map.Entry 인터페이스 ##
    - Map.Entry 인터페이스는 Map 인터페이스 안에 있는 내부 인터페이스 이다.
    - Map 에 저장되는 Key- value 쌍의 Node 내부 클래스가 이를 구현하고 있다.
    - Map 자료구조를 보다 객체지향적인 설계를 하도록 유도하기 위한 것이다.

    ## HashMap 클래스 ##
    - Hashtable을 보완한 컬렉션
    - 배열과 연결이 결합된 Hashing형태로, 키와값을 묶어 하나의 데이터로 저장한다.
    - 중복을 허용하지 않고 순서를 보장하지 않는다.
    - 키와 값으로 null이 허용된다.
    - 추가, 삭제, 검색, 접근성이 모두 뛰어나다.
    - HashMap은 비동기로 작동하기 떄문에 멀티 쓰레드 환경에서는 어울리지않는다.   
    대신(ConcurrentHashMap을 사용한다)

    ## LinkedHashMap 클래스 ##
    - HashMap을 상속하기 떄문에 흡사하지만 Entry들이 연결 리스트를 구성하여 데이터의 순서를 보장한다.
    - 일반적으로 Map 자료구조는 순서를 가지지 않지만, LinkedHashMap은 들어온 순서대로 순서를 가진다.

    ## TreeMap 클래스 ##
    - 이진법 검색 트리의 형태로 키와 값의 쌍으로 이루어진 데이터만을 저장 (TreeSet과 비슷하다.)
    - TreeMap은 SortedMap 인터페이스를 구현하고 있어 Key 값을 기준으로 정렬되는 특직을 가지고 있다.
    - 정렬된 수서로 키/값 쌍을 저장하므로 빠른검색 가능
    - 단 키와 값을 저장하는 동시에 정렬을 행하기 떄문에 저장속도가 느리다.
    - 정렬되는 순서는 숫자-> 대문자 -> 소문자 -> 한글 순이다.

    ## HashTable 클래스 ##
    - 자바 초기버전에 나온 레거시 클래스
    - Key를 톡정 해서 함수를 통해 ㅎ해상한 후 나온 결과를 배열의 인덱스로 사용하여  Value 찾는 방식으로 동작한다.
    - HashMap 보다는 느리지만 동기화가 기본 지원된다.
    - 키와 값으로 null이 허용 불가

    ## Properties 클래스 ##
    - Properties (String, String) 의 형태로 저장하는 단순화된 Key-Value 컬렉션
    - 주로 애플리케이션의 환경 설정과 관련된 속성 파일인.propreties를 설정하는데 사용된다.

    # 컬렉션 프레임워크 선택 시점
    - 종류도 많고 똑같은 자료구조 이지만 각 쓰임새와 특징에 따라 나누니 정리하기 까다롭다.
    
    ## 간단 정리 ##
    ArrayList
    - 리스트 자료구조를 사용한다면 기본 선택
    - 임의의 요소에 대한 접근성이 뛰어남
    - 순차적인 추가/삭제 제일빠름
    - 요소의 추가/ 삭제 불리
    
    LinkedList
    - 요소의 추가/삭제유리
    - 임의의 요소에 대한 접근성이 좋지 않음
    
    HashMap/ HashSet
    - 해시를 이용해 임의의 요소에 대한 추가/ 삭제/ 검색/ 접근성 모두 뛰어남
    - 검색에 최고성능
    
    TreeMap/TreeSet
    - 요소 정렬이 필요할때
    - 검색(특히 범위검색)에 적합
    - 그래도 검색은 HashMap보다 떨어짐
    
    LinkedHashMap/ LinkedHashSet : HashMap과 HashSet에 저장 순서 유지 기능 추가
    
    Queue : 스택(LIFO)/ 큐(FIFO) 자료구조가 필요하면 ArrayDeque 사용
    
    Stack,Hashtable : 가급적 사용 X 
    
    
>>>>>>> master
출처: https://inpa.tistory.com/entry/JCF-🧱-Collections-Framework-종류-총정리 [Inpa Dev 👨‍💻:티스토리]