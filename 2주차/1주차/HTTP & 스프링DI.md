# 2번 박호범


## 웹기초 HTTP

<details>

# HTTP

HTTP : HyperText Transfer Protocol

HyperText : 텍스트 안에 링크를 포함하는 텍스트  
Transfer : 이동하다, 옮기다   
Protocol : 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계 즉, 통신 규약 및 약속

 - 웹에서 데이터를 주고 받기 위한 통신 프로토콜이다.
 - 클라이언트와 서버 간의 통신(문서 혹은 데이터를 주고 받을 때)을 위한 프로토콜로 요청(Request)과 응답(Response)로 구성된다.
 - 주로 웹 브라우저와 웹 서버 간에 사용되며, 기반은 텍스트이다.
 - 웹에서 정보를 가져오거나 전송하는 데 사용되는 통신 규약이다.  

### HTTP 통신
 - 클라이언트(웹브라우저) - HTTP 요청 - 서버
 - 서버 - HTTP 응답 - 클라이언트(웹브라우저)  

#### 예시
"http://www.naver.com/index.html" 페이지를 열 때, 웹 브라우저는 HTTP 요청을 "http://www.naver.com" 서버로 보낸다.  
서버는 요청받은 객체 "/indext.html"을 찾는 데 성공했다면 그것의 타입, 길이 등의 정보를 HTTP 응답에 실어 클라이언트에게 보낸다.  

#### HTTP 통신의 사용의 이유
신뢰성 있는 데이터 전송 프로토콜을 사용해, 데이터 전송 중 손상되거나 꼬이지 않음을 보장
 - 따라서 개발자는 인터넷의 결함이나 약점에 대한 고민 없이 어플리케이션 고유 기능 구현에 집중 가능  


### HTTP 메소드 
 - HTTP의 요청(Request)는 다양한 메소드(Method)를 사용하여 서버에 특정 동작을 요청한다.
 - 일반적으로 사용되는 메소드에는 Get(데이터 조회), Post(데이터 전송), Put(데이터 갱신), Delete(데이터 삭제) 등이 있다.  

## URL(Uniform Resource Locator)과 URN(Uniform Resource Name)
 - 웹에서 특정 리소스를 찾기 위한 식별자  

### URL(Uniform Resource Locator)
 목적 : 특정한 리소스의 위치를 지정하는 데 사용, 주로 웹브라우저에서 사용되며 특정 리소스의 위치를 찾기 위해 쓰인다.  
 형식 : 'scheme://host:port/path?query#fragment'
  - scheme : 리소스에 접근하기 위해 사용되는 프로토콜 (예: http, https)
  - host : 리소스가 위치한 서버의 도메인 이름이나 IP 주소
  - port : 서버와 통신하기 위한 포트 번호 (일반적으로 생략 가능하며, 생략 시 기본값 사용)
  - path : 서버상의 리소스의 경로
  - query : 리소스에 대한 매개변수 (생략 가능)
  - fragment : 리소스의 특정 부분을 가리키는데 사용 (생략 가능)   

### URN(Uniform Resource Name)
 목적 : 리소스의 고유한 이름을 제공하는 데 사용, 주로 리로스의 고유성을 나타내기 위해 사용하며 리소스의 위치가 바뀌어도 동일한 URN을 유지  
 형식 : urn:namespace:identifier  
  - urn: URN임을 나타내는 식별자  
  - namespace: URN이 속하는 특정 네임스페이스 (예: ISBN, ISSN)  
  - identifier: 해당 네임스페이스 내에서 리소스를 식별하는데 사용되는 값  

 URL은 리소스의 위치를 나타내는 데 사용되고, URN은 리소스의 고유한 이름을 나타내는 데 사용된다.  

## HTTP의 요청 구조(클라이언트에서 서버로)
 - HTTP의 요청은 메소드, 헤더, 본문으로 구성된다.
 - 헤더는 요청에 대한 부가적인 정보를 전달하고 본문은 데이터를 포함하고 있다.  

#### HTTP의 응답 구조(서버에서 클라이언트로)
 - HTTP의 응답은 상태 코드, 헤더, 본문으로 구성된다.
 - 상태 코드는 요청의 성공 또는 실패를 나타낸다.  

#### 상태 코드
 - HTTP의 응답에는 성공, Redirection, 클라이언트 오류, 서버 오류 등을 나타내는 상태 코드가 포함되어 있다.
 - 2xx, 3xx, 4xx, 5xx 등이 있다.  

## 쿠키와 세션
 - HTTP는 Stateless(상태를 유지하지 않는) 프로토콜이므로, 쿠키와 세션을 통해 상태를 유지한다.
 - 쿠키는 클라이언트에 저장되는 작은 데이터의 조각이고, 세션은 서버에 저장된 정보이다.  

## HTTPS : HTTP에 보안의 기능을 더한 것
 - S : Secure(안전한)의 약자이다.
 - 데이터를 암호화 해서 보낸다.
 - SSL/TLS 인증서를 사용하여 자신의 신원을 증명하기 때문에 클라이언트와 서버 간 통신의 안전성을 보장한다.
 - 위와 같은 과정을 거치기 때문에 전송 속도가 HTTP보다 조금 더 느리다.
 - 최근에는 보안의 중요성이 대두되어 HTTPS를 선호하는 추세이다.
  

## < 질문과 답변 >

HTTP는 HTML 문서에 대한 정보를 보내는가?
 - 주로 HTML 데이터를 전송하는데 사용되지만, 다양한 유형의 데이터를 전송할 수 있다.
 - HTML 뿐만 아니라 텍스트 파일, 이미지, 오디오 및 비디오, JSON 및 XML 데이터, 기타 바이너리 데이터도 보낸다.  
  &nbsp;- HTML : 주로 웹 페이지의 구조와 콘텐츠를 전송하는데에 사용  
  &nbsp;- 텍스트 파일 : 일반 텍스트 파일 혹은 다양한 텍스트 기반의 데이터를 전송  
  &nbsp;- 이미지 : JPEG, PNG, GIF 등의 이미지 파일 전송  
  &nbsp;- 오디오 및 비디오 : MP3, MP4 등 오디오 및 비디오 파일을 전송  
  &nbsp;- JSON 및 XML 데이터 : 웹 애플리케이션 간에 데이터를 교환하는데 사용  
  &nbsp;- 기타 바이너리 데이터 : 임의의 이진 데이터 전송  
</details>



## 스프링 : 스프링 DI(Dependency Injection - 의존주입)

<details>
	# Spring DI 

## DI : Dependency Injection(의존성 주입)
 - 객체 지향 프로그래밍에서 사용되는 설계 패턴 중 하나로, 객체 간의 의존성을 외부에서 주입하는 방법이다.
 - DI를 통해 객체는 직접 자신이 필요로 하는 의존 객체를 생성하지 않고, 외부에서 주입 받아 사용한다.  
 - 즉, new 연산자를 통해 객체를 직접 생성하는 것이 아니라 외부에서 생성된 객체를 주입받아 이용하는 것이다.

### 의존성
- 객체가 다른 객체를 사용하고 있는 경우 즉, A객체가 없이는 B객체가 원하는 목적으로 사용될 수 없는 경우를 뜻한다.  
- 의존한다는 것은 의존 대상인 A객체가 변하면 그것이 B객체에 전달되고, A객체의 메소드가 변경되면 B객체에서도 그에 따른 수정이 필요한 것을 의미한다.  
- 또한 A객체의 형식은 그대로지만 로직이 변경되면 결과적으로 B객체의 기능에 영향을 미치는 것도 의존 관계에 있다고 할 수 있다.

### 따라서 의존성 주입은 두 객체 간의 관계를 맺어주는 것이다.

## DI(의존 주입)를 사용하는 이유
 - 코드의 재사용성, 유연성이 높아진다.  
&nbsp; - 하나의 작업만 수행하는 작은 객체는 많은 상황에서 재결합하고 재사용하기가 쉽기 때문이다.
 
 - 객체 간 결합도가 낮기 때문에 한 클래스를 수정했을 때 다른 클래스도 수정해야 하는 상황을 막아준다.
 
 - 유지보수가 쉬우며 테스트가 용이해진다.
 
 - 확장성을 가진다.

## IoC Inversion of Control(제어의 역전)   
 - 메소드나 객체의 호출작업을 개발자가 직접 하는 것이 아닌, 스프링 프레임워크에게 제어권을 넘기는 것이다. 
 - 대부분의 프레임워크에서 IoC를 적용하고 있고 스프링 또한 여러 프레임워크 중 하나이다.
 - @componentScan, @autowired 등을 예시로 들 수 있다.
유들 때문에 여러 DI 방법 중 생성자주입 방식을 권장하고 있다.

### 의존성을 생성자로 주입했을 때는 컴파일 에러 발생으로 프로그램 실행 자체가 되지 않으므로 서비스 전 에러를 해결 할 수 있다.
</details>

## Spring DI : 스프링에서의 의존성 주입
 - 객체 간 의존성을 개발자가 객체 내부에서 직접 호출(new 연산자 생성)하는 대신, 외부(스프링 컨테이너)에서 객체를 생성 후 주입해주는 방식이다.  
 - 외부(스프링 컨테이너)에서 두 객체 간의 관계 설정을 해주는 디자인 패턴으로, 인터페이스를 사이에 두어 클래스 레벨에서는 의존 관계가 고정되지 않도록 한다.  
 - 런타임 시 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮춘다.    

## 의존성 주입의 3가지 방법  
  
### 1. 생성자 주입  
 - 클래스에 생성자를 만든 후 @Autowired를 붙여 의존성을 주입받는 방법
 -  Spring 4.3 이후 클래스 내 생성자가 하나이고, 그 생성자로 주입받을 객체가 빈으로 등록되어 있다면 @Autowired를 생략 가능하다.
 -  객체의 성격에 맞게, 빈의 이름이 달라질 수 있다.
 - 생성자 주입은 인스턴스 생성 시 1회 호출되는 것이 보장되기 때문에, 주입 받은 객체가 변하지 않거나 반드시 객체 주입이 필요한 경우 강제하기 위해 사용된다.
 -  생성자를 2회 이상 정의할 수 없다.  

### 2. 필드 주입  
 - 코드가 간결하고 편하지만 의존 관계를 정확히 파악하기 함들다.    
 - 필드 주입 시 final 키워드를 선언할 수 없어 객체가 변할 수 있다.   
 - 주입이 동시에 일어나 겹치는 경우 순환참조 에러가 발생한다.    

### 3. 수정자(setter) 주입    
 - setter 혹은 사용자 정의 메소드를 통해 의존 관계 주입한다.    
 - setter의 경우 객체가 변경될 필요성(주입하는 객체를 변경하는 경우는 드묾)이 있을 때만 사용한다.    

## 스프링에서는 생성자 주입을 권장하는 이유
 
### 객체 불변성 확보  
 - 객체의 생성자는 객체 생성 시 최초 1회만 호출되기 때문에 주입 받은 객체가 불변 객체(메소드 변화 X)여야 하거나 반드시 해당 객체의 주입이 필요한 경우 사용한다.  
 - 생성자로 한번 의존 관계를 주입하면 생성자는 최초 1회 이후 다시 생성될 일이 없기 때문에 불변객체가 보장된다.

### 테스트 용이
 - 필드 주입으로 작성된 경우, 순수 자바 코드로 단위테스트를 실행하는 것이 불가능하다.
 - 메인 코드는 Spring과 같은 DI 프레임워크 위에서 동작하는데 단위테스트 시 단독적으로 실행되므로 의존관계 주입이 NULL 상태여서 NullPoninterException이 발생한다.
 - 생성자 주입 시 단독으로 실행할 때도 의존관계 주입이 성립된다.

### 순환참조 에러 방지
 - 순환참조 에러 : A객체는 B객체를 참조하고, B객체는 A객체를 참조해 두 객체가 서로를 동시에 참조할 때 발생한다.


### 의존성을 필드로 혹은 수정자(setter)로 주입시킬 경우, 프로그램 실행 중 에러가 발생한다.
 - 이때 컴파일 시에는 아무런 에러가 없다가 메소드 호출시에 발생한다는 것이 큰 문제가 된다.


### 이러한 이