## 객체 지향 프로그래밍

소프트웨어를 개발할 때 현실 세계의 부품에 해당하는 객체를 먼저 만들고 객체를 하나씩 조립해서 완성된 프로그램을 만드는 기법을 객체 지향 프로그래밍 (OOP : Objerct-Oriented Programming)이라 한다.

## 객체 (Object)

물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별가능한 것.

> 물리적 객체 - 자동차, 자전거, 책, 사람 등…
>
>
> 추상적 객체 - 학과, 강의, 주문 등…


객체는 속성 (필드 (field))과 동작 (메소드 (method))으로 구성되어 있다.

> 사람 : 속성 - 이름, 나이 등
동작 - 울다, 걷다 등

자동차 : 속성 - 색깔, 모델명 등
동작 - 달린다, 멈춘다 등
>
> - 객체의 특징
1. 객체의 상호작용

객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작하며, 이때 객체들 사이의 상호작용 수단은 **메소드**이다. 객체가 다른 객체의 기능을 이용하는 것을 **메소드 호출**이라 한다.

- 객체에 도트 ( . ) 연산자를 붙이고 이름을 기술한다.
  ※ 도트 ( . ) 연산자 : 객체의 필드와 메소드에 접근할 때 사용
- 매개값은 메소드를 실행시키기 위해 필요한 데이터이며 리턴값은 메소드가 실행되고 난 후 호출한 곳으로 돌려주는 (리턴하는) 값이다.

```java
리턴값 = 객체.메소드(매개값1, 매개값2, ...);
int result = Calculator.add(10, 20);
```

**객체의 상호작용은 객체 간의 호출을 의미하며 매개값과 리터값을 통해서 데이터를 주고받는다.**

1. 객체 간의 관계

객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고있다.

1) 집합 관계

하나는 부품, 하나는 완성품에 비유할 수 있는데, 여러 가지 부품들의 집합이 모여 하나의 완성품 객체를 만든다.

> 자동차는 엔진, 타이어, 핸들 등의 부품으로 구성되므로 **자동차와 부품들은 집합 관계**이다.
>

2) 사용 관계

객체 간의 상호작용을 말한다. 객체는 다른 객체의 메소드를 호출해 원하는 결과를 얻어낸다.

> 사람은 자동차를 사용할 때 달린다, 멈춘다 등의 메소드를 호출하기 때문에 **사람과 자동차는 사용 관계**이다.
>

3) 상속 관계

상위 (부모) 객체를 기반으로 하위 (자식) 객체를 생성하는 관계를 말한다.

일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당한다.

> 자동차는 기계의 한 종류이다.
→ **기계 (상위)와 자동차 (하위)는 상속 관계**이다.
>

## 객체와 클래스

현실에서 객체는 설계도를 바탕으로 만들듯이 객체 지향 프로그래밍에서도 메모리에서 사용하고 싶은 객체가 있다면 설계도로 해당 객체를 만드는 작업이 우선되어야 한다.

## 클래스

- 객체를 만들기 위한 설계도. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.
- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다.
- 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다.
  ex) 자동차 객체는 자동차 클래스의 인스턴스인 셈이다.
- 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있는데, 이것은 동일한 설계도로부터 여러 대의 자동차를 만드는 것과 동일하다.

### 객체 지향 프로그래밍 개발 3단계

1. 클래스 설계
2. 설계된 클래스를 가지고 사용할 객체를 생성
3. 생성된 객체를 이용

- 클래스 선언

사용하고 하는 객체를 구상했다면 객체의 대표 이름을 결정하고 이것을 클래스 이름으로 정한다.

참고)
클래스 이름은 다른 클래스와 식별할 목적으로 사용되므로 식별자 작성 규칙에 따라 만들어야 한다.

```java
class Car {
	// 필드
	// 생성자
	// 메서드
}
```

- 객체 생성

클래스로부터 객체를 생성하려면 new 연산자를 사용한다.

new 연산자는 클래스로부터 객체를 생성시키는 연산자이다. new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스( ) 형태를 가지고 있다.

> ① 클래스 변수; → 변수 선언
② 변수 = new 클래스( ); → 변수에 값 대입
클래스 변수 = new 클래스( ); → ① + ② = 초기화, 객체 생성
>

```java
class Car {
	Car myCar; // 객체 변수 선언
	myCar = new Car(); // 객체 생성
	// Car myCar = new Car(); // 객체 선언 & 생성
}
```

## 인스턴스 변수와 스태틱 변수

### 인스턴스 변수

- 클래스 내에서 선언된 변수 중, 객체마다 고유한 값을 가지는 변수이다.
- 즉, 여러 개의 객체를 생성하면 각 객체의 인스턴스 변수는 서로 다른 값을 가질 수 있다.
- 인스턴스 변수는 객체의 상태를 나타내는 용도로 사용된다.

### 스태틱 변수

- 클래스 내에서 선언된 변수 중, 모든 객체가 공유하는 변수이다.
- 여러 개의 객체를 생성해도 하나만 존재하며, 초기화가 힌번만 진행된다. (주로 전역변수, 상수로 이용된다.)

- 스태틱 변수는 모든 객체에서 동일한 값을 갖는다. 클래스 변수는 객체들 간에 공유해야 할 값을 저장하는 용도로 사용된다.

- 객체 생성 없이 '클래스명.스태틱변수명' 으로 접근 가능하다.

> 원카드에 사용되는 카드에는 여러 특징이 있고, 각 카드를 객체라고 할 수 있다.
> 카드의 속성에는 문양과, 숫자, 카드의 폭, 넓이 등이 있다.
> 폭, 넓이는 모든 카드가 공통으로 가지고 있는 속성이다.

```java
class Card { 
    // 인스턴스 변수 선언
    String kind; // 무늬
    int number; // 카드 숫자

    // 스태틱 변수 선언
    // 모든 인스트턴스가 공통된 저장공간 (변수)을 공유한다.
    // 모든 인스턴스들이 공통적인 값을 유지해야 하는 경우 사용한다.
    static int width = 50; // 폭
    static int height = 250; // 넓이
}

public class Variable {
    public static void main(String[] args) {
        System.out.println("Card.width = " + Card.width);
        System.out.println("Card.height = " + Card.height);

        Card c1 = new Card();
        c1.kind = "Heart";
        c1.number = 7;

        Card c2 = new Card();
        c2.kind = "Spade";
        c2.number = 6;

        System.out.printf("c1의 종류는 %s c1의 번호는 %d, 카드 규격은 [%d * %d] 입니다.%n", c1.kind, c1.number, c1.width, c1.height);
        System.out.printf("c2의 종류는 %s c2의 번호는 %d, 카드 규격은 [%d * %d] 입니다.%n%n", c2.kind, c2.number, c2.width, c2.height);

        System.out.println("c1의 카드 규격을 [200 * 450]으로 변경합니다");
        System.out.println();
        c1.width = 200;
        c1.height = 450;
        // width와 height는 클래스 변수기 때문에 값을 변경하면 c2도 같이 변경된다

        System.out.printf("c1의 종류는 %s c1의 번호는 %d, 카드 규격은 [%d * %d] 입니다.%n", c1.kind, c1.number, c1.width, c1.height);
        System.out.printf("c2의 종류는 %s c2의 번호는 %d, 카드 규격은 [%d * %d] 입니다.%n", , c2.kind, c2.number, c2.width, c2.height);
    }
}

실행 결과
Card.width = 50
Card.height = 250
c1의 종류는 Heart c1의 번호는 7, 카드 규격은 [50 * 250] 입니다.
c2의 종류는 Spade c2의 번호는 6, 카드 규격은 [50 * 250] 입니다.

c1의 카드 규격을 [200 * 450]으로 변경합니다

c1의 종류는 Heart c1의 번호는 7, 카드 규격은 [200 * 450] 입니다.
c2의 종류는 Spade c2의 번호는 6, 카드 규격은 [200 * 450] 입니다.
```

### 인스턴스 변수와 스태틱 변수의 차이점

1. 선언 위치
   인스턴스 변수는 클래스 내부에 선언되지만 스태틱 변수는 static 키워드를 사용해 클래스 내부에 선언된다.

2. 객체의 생성 여부
   인스턴스 변수는 객체가 생성될 때마다 새로운 메모리 공간이 할당되며, 각 객체의 인스턴스 변수는 서로 다른 값을 가질 수 있다. 하지만 스태틱 변수는 객체의 생성 여부와는 무관하게 프로그램이 실행될 때 메모리에 할당되며, 프로그램이 종료될 때까지 사용된다.

3. 접근 방법
   인스턴스 변수는 객체를 통해 접근할 수 있지만, 스태틱 변수는 객체를 생성하지 않아도 클래스 이름을 통해 접근할 수 있다.

3. 용도
   인스턴스 변수는 객체의 상태를 나타내는 용도로 사용되며, 스태틱 변수는 객체들 간에 공유해야 하는 값을 저장하는 용도로 사용된다.


# 메소드

- 객체의 동작에 해당하는 중괄호 { } 블록을 말하며, 메소드를 호출하면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
- 메소드 선언은 선언부와 실행 블록으로 구성된다.
- 메소드 선언부를 메소드 시그니처라 하며, 선언부와 실행 블록에는 여러 요소들이 포함된다.
1. 리턴 타입
   메소드가 리턴하는 결과의 타입을 표시

2. 메소드 이름
   메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 짓는다.

3. 매개 변수 선언
   메소드를 실행할 때 필요한 데이터를 받기 위한 변수를 선언한다.

4. 메소드 실행 블록
   실행할 코드를 작성한다.

```java
리턴타입 메소드이름 (매개변수, ....) {

	실행할 코드 작성

}
```

```
int sum (int num1, int num2) {
	int answer;
	answer = num1 + num2;

	return answer;
}
```

## 메소드 선언

메소드 선언은 선언부 (리턴 타입, 메소드 이름, 매개 변수 선언)와 실행 블록으로 구성된다.

- 리턴 타입

리턴값의 타입. 리턴 값이란 메소드를 실행한 후의 결과값을 말한다.

메소드는 리턴값이 있을수도 없을 수도 있으나 리턴값이 있을 경우 리턴 타입이 선언부에 명시되어야 한다.

리턴값이 없는 메소드는 리턴 타입에 void로 기술하며, 리턴값이 있는 메소드는 리턴값의 타입을 기술한다.


## 메소드 이름

메소드가 어떤 기능을 수행하는지 알기 쉽도록 기능 이름으로 지어주는 것이 좋다.

## 매개 변수

메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다.

- 매개 변수가 있는 divide( ) 메소드 선언

double divide (int x, int y) { ... }

- 선언된 divide() 메소드를 호출할 때 2개의 int 값을 주어야 한다.

double result = divide (10, 20);

## 매개 변수의 개수를 모를 경우

여러 개의 수를 모두 합산하는 메소드를 선언해야 한다면 몇 개의 매개 변수가 입려될지 알 수 없기 때문에 매개변수의 개수를 결정할 수 없을 것이다.

해결책은 매개 변수를 배열 타입으로 선언하는 것이다.

int sum (int [ ] values) { }

## 리턴문

메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야 한다.

return 문이 없다면 컴파일 에러가 발생하고, return 문이 실행되면 메소드는 종료된다.

return 리턴값;

return 문의 리턴값은 리턴 타입이거나 리턴 타입을 변환될 수 있어야 한다.

```java
int plus (int x, int y) {

     int result = x + y;

     return result;

}
```

- return 문 이후의 실행문은 절대 실행되지 않기 때문에 return 이후에 실행문이 오면 “Unreachable code" 컴파일에러가 발생한다.

만일, 뒤에 실행문이 추가적으로 더 있을 경우에는 return문이 아니라 break문을 사용해야 한다.

## 리턴값이 없는 메소드 void

리턴값이 없는 메소드는 리턴 타입으로 void를 사용하지만 void로 선언된 메소드에서도 return문은 사용할 수있다. 이는 리턴값을 지정하는 것이 아니라 메소드 실행을 강제 종료시킨다.
```java
    return;
```

## 메소드 호출

메소드는 클래스 내, 외부의 호출에 의해 실행된다.

클래스 외부에서 호출할 경우에는 클래스로부터 객체를 생성하고 참조 변수를 이용해 메소드를 호출해야 한다.

- 객체 내부에서 호출

클래스 내부에서 다른 메소드를 호출하는 경우에는 객체를 생성할 필요 없이 메소드 이름으로 호출하면 된다.
```java
메소드 ( 매개값, ...) ;
```
메소드가 매개 변수를 가지고 있을 때는 매개 변수의 타입과 수에 맞게 매개값을 제공한다.

```java
public class Calc {
    int plus(int x, int y) {
        int result1 = x + y;
        return result1;
    }

    double avg(int x, int y) {
        double sum = plus(x, y); // 2. plus 호출
        double result2 = sum / 2;
        return result2;
    }

    void execute() {
        double result3 = avg(7, 10); // 1. avg 호출
        println("실행 결과 : " + + result3); // 3. prinln 호출
    }

    void println (String msg) {
        System.out.println(msg);
    }

    public static void main(String[] args) {
        Calc calc = new Calc();
        calc.execute(); // 4. execute 호출
    }
}

실행 결과
실행 결과 : 8.5
```

# 객체 외부에서 호출

클래스 외부에서 다른 메소드를 호출할 경우 클래스로부터 객체를 생성한다. 메서드는 객체에 소속된 멤버이므로 객체가 존재하지 않으면 메서드도 존재하지 않기 때문이다.

객체가 생성되면 참조 변수와 함께 도트 (.) 연산자를 사용해서 메서드를 호출한다.

```java
클래스 참조변수 = new 클래스 (매개값, ...);

참조변수.메서드 (매개값, ...); // 리턴값이 없거나, 있어도 리턴값을 받지 않을 경우
타입 변수 = 참조변수.메서드 (매개값, ...); // 리턴값이 있고, 리턴값을 받고 싶은 경우
```

```java
public class Car {
	int speed; // 필드

	// 생성자

	// 메서드
	int getSpeed() {
		return speed;
	}

	void keyTurnOn() {
		System.out.println("키를 돌린다");
	}

	void run() {
		for (int i = 0; i <= 10; i++) {
			speed = i;
			System.out.println("달린다. (시속 : " + speed + "km/h)");
		}
	}
}
```

```java
public class CarEx {
	public static void main(String[] args) {
		Car myCar = new Car(); // Car 객체 생성

		myCar.keyTurnOn(); // Car 객체의 메서드 호출 리턴값이 없음
		myCar.run(); // Car 객체의 메서드 호출 리턴값이 없음
		int speed = myCar.getSpeed(); // Car 객체의 메서드 호출 리턴값이 있고 변수 speed에 저장
		Systemp.out.println("현재 속도 : " + speed + "km/h)");
	}
}

실행 결과
키를 돌린다
달린다. (시속 : 0km/h)
달린다. (시속 : 1km/h)
달린다. (시속 : 2km/h)
달린다. (시속 : 3km/h)
달린다. (시속 : 4km/h)
달린다. (시속 : 5km/h)
달린다. (시속 : 6km/h)
달린다. (시속 : 7km/h)
달린다. (시속 : 8km/h)
달린다. (시속 : 9km/h)
달린다. (시속 : 10km/h)
현재 속도 : 10km/h)
```
