# 객체 / 다형성

자바는 객체 지향 프로그래밍(OOP; Object Oriented Programming) 언어 중 대표적인 언어이다.

객체 지향 프로그래밍은 프로그래밍에서 필요한 데이터를 추상화시켜 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 객체를 만들고, 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 방법을 의미한다.

### 객체(object)

물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 **자신의 속성을 가지고 있고, 다른 것과 식별이 가능한 것**

자바에서는 클래스에서 생성된 데이터를 객체로 정의한다.

### 클래스(class)

클래스는 객체를 만들기 위한 틀 혹은 설계도라 할 수 있다.

클래스는 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메소드로 구성된다.

ex) 흔히 붕어빵(객체)를 만들기 위한 붕어빵 틀(클래스)라고 비유한다.

```java
pubilc class 클래스이름 {
	int	property; // 속성 (멤버 필드)

	void methodName(){ ... } // 메소드   
}
```

**속성 (property)**

속성은 클래스내에 있는 변수, 곧 객체의 상태를 말한다.

일반 변수와 속성의 차이점은 변수는 해당 메소드와 생성자에서만 사용되고

메소드, 생성자가 종료됨과 동시에 메모리가 소멸된다.

필드는 클래스 안의 전체 메소드와 생성자에서 사용되고 객체가 소멸될때까지 존재한다.

**메소드 (method)**

메소드는 클래스함수, 멤버함수로도 불리며 클래스에 종속되어 인스턴스와 연결되어 있는 어떤 특정 작업을 수행하기 위한 명령문의 집합이다.

클래스에 종속되어 있기 때문에 해당 클래스에 대한 객체가 생성이 되어야 사용할 수 있다.

**클래스를 통해 객체를 생성하는 방법**

참조 변수를 선언하고 new 키워드를 사용하여 인스턴스를 생성한다.

```java
Car c1 = new Car();
```

### 인스턴스(**Instance**)

클래스가 붕어빵 틀이라면, 그 틀을 통해 생성된 객체들을 해당 클래스의 인스턴스라고 한다.

클래스를 사용하여 힙 영역에 새로운 인스턴스 객체를 생성할 수 있다. (메모리에 할당)

인스턴스는 객체가 실체화 된 것이며 그 과정을 인스턴스화라고 한다.

---

**다형성(polymorphism)**

다형성(polymorphism)이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미합니다.

(하나의 변수로 다른 타입의 다양한 객체를 참조할 수 있다.)

자바에서는 이러한 다형성을 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현하고 있습니다.

다형성은 상속, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나입니다.

```java
class Parent { ... }
class Child extends Parent { ... }

...

Parent pa = new Parent(); // 허용
Child ch = new Child();   // 허용
Parent pc = new Child();  // 허용
Child cp = new Parent();  // 오류 발생.
```

부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있습니다.

하지만 반대의 경우인 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없습니다.

<aside>
💡 클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없으므로, 자식 클래스에서 사용할 수 있는 멤버의 개수가 언제나 부모 클래스와 같거나 많게 됩니다.

</aside>
<br>

**참조 변수의 타입 변환**

1. 서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있습니다.
2. 자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략할 수 있습니다.
3. 하지만 부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 합니다.

```java
class Parent { ... }
class Child extends Parent { ... }
class Brother extends Parent { ... }

...

Parent pa01 = null;
Child ch = new Child();
Parent pa02 = new Parent();
Brother br = null;

pa01 = ch;          // pa01 = (Parent)ch; 와 같으며, 타입 변환을 생략할 수 있음.
br = (Brother)pa02; // 타입 변환을 생략할 수 없음.
br = (Brother)ch;   // 직접적인 상속 관계가 아니므로, 오류 발생.
```

| 자식타입 -> 부모타입<br>( Up - casting ) | 형변환 생략 가능 | - 부모 타입의 객체에 자식 클래스의 필드를 담아주는 것<br> - 부모 타입의 객체에 자식 객체를 넣어주는 것                                                    <br>- 부모 타입의 객체에 자식 생성자를 호출해주는 것 |
| --- | --- | --- |
| 부모타입 → 자식타입<br>( Down - casting ) | 형변환 생략 불가능 | - 업캐스팅된 객체를 다시 자식 객체에 담는 기법<br>** 업캐스팅이 되어있어야만 다운 캐스팅이 가능함 |

형변환은 참조 변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것이 아니기 때문에 참조 변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.

**다형성의 장점**

정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나임

다형성을 잘 활용하면 **유연하고 확장성있고, 유지보수가 편리한** 프로그램을 만들수 있음

**instanceof 연산자**

이러한 다형성으로 인해 참조 변수가 실제로 참조하고 있는 인스턴스의 타입을 확인할 필요성이 생깁니다.

자바에서는 instanceof 연산자를 제공하여, 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 확인할 수 있도록 해줍니다.

```java
참조변수 instanceof 클래스이름
```

왼쪽에 전달된 참조 변수가 실제로 참조하고 있는 인스턴스의 타입이 오른쪽에 전달된 클래스 타입이면 true를 반환하고, 아니면 false를 반환합니다.

만약에 참조 변수가 null을 가리키고 있으면 false를 반환합니다.

```java
class Parent { }
class Child extends Parent { }
class Brother extends Parent { }

public class Polymorphism01 {

    public static void main(String[] args) {
        Parent p = new Parent();

        System.out.println(p instanceof Object); // true
        System.out.println(p instanceof Parent); // true
        System.out.println(p instanceof Child);  // false

        System.out.println();

        Parent c = new Child();

        System.out.println(c instanceof Object); // true
        System.out.println(c instanceof Parent); // true
        System.out.println(c instanceof Child);  // true

    }

}
```

instanceof를 이용한 연산 결과로 true를 얻었다는 것은 참조 변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

**참조변수와 인스턴스의 연결**

부모클래스에 선언된 멤버 변수와 같은 이름의 인스턴스 변수를 자식클래스에서 중복으로 정의 했을 때 Parent c = new Child(); 인 경우와 Child c = new Child(); 인 경우는 서로 다른 결과를 얻는다.

메소드의 경우 부모클래스의 메소드를 자식의 클래스에서 오버라이딩한 경우에는 참조 변수의 타입에 관계없이 항상 실제 인스턴스 메소드가 호출되지만, 멤버 변수의 타입에 따라 달라진다.

멤버 변수가 부모클래스와 자손클래스에 중복으로 정의된 경우,부모 타입의 참조 변수를 사용했을 때는 부모클래스에 선언된 멤버 변수가 사용되고, 자식 타입의 참조 변수를 사용했을 때는 자식 클래스에 선언된 멤버 변수가 사용된다.