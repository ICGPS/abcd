## 객체 지향 프로그래밍과 클래스
<details>
- 설명
    
    ### 객체와 객체 지향 프로그래밍
    
    - 사물은 모두 객체라고 할 수 있습니다.
    - 눈에 안 보이는 것도 객체가 될 수 있습니다. 주문, 생산, 관리 등
    - 객체지향 프로그램이란 '**어떤 대상(객체)**'을 가지고 프로그래밍한다는 것
    
    ### 생활 속에서 객체 찾아보기
    
    - 절차 지향 프로그래밍 : 순서대로 일어나는 일을 시간순으로 프로그래밍 하는 것
    - 객체 지향 프로그래밍 : 객체를 정의하고 객체 간 협력을 프로그래밍 하는 것
        - 객체지향 프로그램은 먼저 객체를 만들고 객체 사이에 일어나는 일을 구현하는 것
        - 객체지향 프로그래밍을 할 때는 객체를 먼저 정의하고 각 객체가 어떤 기능을 제공하고 객체 간 협력을 어떻게 구현할 것인지를 고민해야 한다.
    
    ## 클래스 살펴보기
    
    - 클래스는 객체의 속성(멤버 변수)과 기능(메서드 / 멤버 함수)을 코드로 구현한 것입니다.
    - 객체를 클래스로 구현한다는 것을 '**클래스를 정의한다**'라고 합니다.
    
    ### 클래스를 정의하는 문법
    
    ```java
    (접근제어자) class 클래스 이름 {
    	멤버변수;
    	메서드;
    }
    
    ```
    
    ```java
    package day05_07;
    
    public class Student {
    	int studentID; // 학번
    	String studentName; // 학생이름
    	int grade; // 학년
    	String address; // 사는 곳
    }
    ```
    
    - 클래스 외부에는 package 선언과 import문장 외에 아무것도 선언하지 않습니다.
    
    ### 클래스 이름을 짓는 규칙
    
    - 클래스 이름은 대문자로 시작합니다.(파스칼 케이스 - 첫 시작 단어는 대문자로 예) OrderInfo, OrderItems) - 관습처럼 사용되는 규칙입니다.
    - 관습을 따르면 각 명칭의 용도를 쉽게 유추할 수 있습니다.
    
    ### 클래스의 속성을 구현하는 멤버변수
    
    - 클래스에 선언하여 객체 속성을 나타내는 변수가 멤버 변수(member variable)입니다.
    
    ```java
    public class Student {
    	int studentID; // 학번
    	String studentName; // 학생이름
    	int grade; // 학년
    	String address; // 사는 곳
    }
    ```
    
    - 멤버변수 / 속성(property) / 특성(attribute)
    - 선언 방법
        
        → 자료형 변수명;
        
    
    ### Person 클래스 만들기
    
    ```java
    package day05_07;
    
    public class Person {
    	String name; // 이름
    	int height; // 키
    	double weight; // 몸무게
    	char gender; // 성별
    	boolean married; // 결혼여부
    }
    ```
    
    - int, double형 같은 **기본자료형**(primitive data type)으로 선언할 수도 있고,
    - 또 다른 클래스형(참조자료형)으로 선언할 수도 있습니다.
        - 참조자료형으로 사용하는 클래스는 String, Date와 같이 이미 JDK에서 제공하는 것일 수도 있고, 개발자가 직접 만든 Student나 Person같은 클래스가 다른 클래스에서 사용하는 멤버변수의 자료형이 될 수 있습니다.
    
    ### 변수의 자료형
    
    | 기본자료형 | 참조자료형 |
    | --- | --- |
    | int, long, float, double등 | String, Date, Student 등 |
    
    ## 클래스와 인스턴스
    
    - 클래스에서는 학생 객체가 가지고 있는 속성을 사용해 학생과 관련된 기능을 구현할 수 있습니다.(예 : '학생에게 이름을 부여한다.', '학생이 사는 곳을 출력한다.')
    - 클래스 내부에서 멤버 변수를 사용하여 클래스의 기능을 구현한 것을 '**멤버 함수**(member function)' 또는 '**메서드**(method)'라고 합니다.(메서드로 용어를 통일하여 진행)
    
    ### 학생 이름과 주소를 출력하는 메서드 만들기
    
    ```java
    public class Student {
    	int studentID; // 학번
    	String studentName; // 학생이름
    	int grade; // 학년
    	String address; // 사는 곳
    
    	public void showStudentInfo() {
    		System.out.println(studentName + "," + address); // 이름, 주소 출력
    	}
    }
    ```
    
    ### 패키지란?
    
    - 클래스파일의 묶음
    - 패키지를 만들면 프로젝트 하위에 물리적으로 디렉토리가 생성됩니다.
    - 패키지는 계층구조를 가지고 있습니다.
    - 패키지가 단순히 클래스 묶음이 아닌 프로젝트 전체 소스 코드를 구성하는 계층구조가 되고, 이 계층구조를 잘 구성해야 소스 코드 관리와 유지보수가 편리합니다.
    
    ### 패키지 선언하기
    
    - 자바 소스 코드에서 클래스의 패키지 선언은 다음처음 맨 위에서 합니다.
    
    ```java
    package domain.student.view
    
    public class StudentView {
    	...
    }
    
    ```
    
    - 클래스 이름은 StudentView이지만, 클래스의 전체 이름(class full name)은 domain.student.view.StudentView입니다.
    - 클래스 이름이 같다고 해도 패키지 이름이 다르면 클래스 전체 이름이 다른 것이므로 다른 클래스가 됩니다.
    - 같은 이름의 클래스라도 다른 패키지에 속해 있으면 서로 연관이 없습니다.
    

## 메서드

- 메서드는 함수(function)의 한 종류 입니다.
    
    ### 함수란?
    
    - 하나의 기능을 수행하는 일련의 코드
    - 함수는 어떤 기능을 수행하도록 미리 구현해 놓고 필요할 때마다 호출하여 사용할 수 있습니다.
    
    ### 함수 정의하기
    
    함수가 하는 일을 코드로 구현하는 것을 **함수를 정의 한다** 라고 합니다.
    
    - 함수이름, 매개변수, 반환값
    
    ### 함수의 입력과 반환
    
    - 함수는 이름이 있고, 입력된 값과 결과 값을 갖습니다.
    - 두 수를 더하는 함수를 예로 들면 두 수를 입력받아서 '더하기 함수'를 거치면 두 수의 합을 반환합니다.
        
        ```java
        public int add(int num1, int num2) {
        /*
        이름이 add인 함수 : 기능이 무엇인지 알 수 있도록 명명
        int num1, int num2 : 메서드에 사용되는 매개변수
        */
        
        		return num1 + num2;
        		// num1 + num2를 결과로 반환한다는 뜻, 반환값
        }
        ```
        
    - 매개변수가 없는 함수
        
        ```java
        int getTenTotal() {
        	int i;
        	int total = 0;
        	for(i = 1; i <= 10; i++) {
        		total += i;
        	}
        
        	return total;  // 1부터 10까지 더한 값을 반환
        }
        
        ```
        
    - **반환값이 없는 함수**
        
        ```java
        void printGreeting(String name) {
        // void : 반환할 값이 없다는 뜻의 예약어
        	System.out.println(name + "님 안녕하세요");
        	return; // 반환값 없음 (생략 가능)
        }
        
        ```
        
    - return 예약어는 함수 수향을 끝내고 프로그램 흐름 중에서 호출한 곳으로 다시 되돌아갈 때도 사용할 수 있습니다.
    
    ```java
    // 나누기 메서드
    void divide(int num1, int num2) {
    		if (num2 == 0) {
    				System.out.println("나누는 수는 0이 될 수 없습니다.");
    				return; // 함수 수행 종료
    		} else {
    				int result = num1 / num2;
    				System.out.println(num1 + "/" + num2 + "=" + result + "입니다.");
    		}
     }
    ```
    
    ### 함수 호출하고 값 반환하기
    
    함수를 사용하는 것을 **함수를 호출한다**라고 합니다.
    
    ```java
    public class FunctionTest {
    		public static void main(String[] args) {
    				int num1 = 10;
    				int num2 = 20;
    
    				int sum = add(num1, num2); // add() 함수 호출
    				System.out.println(num1 + " + " + num2 + " = " + sum + "입니다.");
    		}
    
    		// add() 함수
    		public static int add(int n1, int n2) {
    				int result = n1 + n2;
    				return result; // 결과 값 반환
    		}
    }
    
    // 실행결과
    // 10 + 20 = 30입니다.
    ```
    
    ### 매개변수 살펴보기
    
    - add() 함수를 호출할 때 num1, num2 두개의 변수를 넘겼습니다.
    - 함수를 구현하는 부분에서는 add(int n1, int n2)와 같이 n1, n2를 사용했습니다.
    - num1과 n1, num2와 n2는 전혀 상관이 없습니다.
    
    ![https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/add()%ED%95%A8%EC%88%98%EB%A5%BC%20%ED%98%B8%EC%B6%9C%ED%95%A0%EB%95%8C%20%EA%B0%92%EC%9D%B4%20%EC%A0%84%EB%8B%AC%EB%90%98%EB%8A%94%20%EA%B3%BC%EC%A0%95.png](https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/add()%ED%95%A8%EC%88%98%EB%A5%BC%20%ED%98%B8%EC%B6%9C%ED%95%A0%EB%95%8C%20%EA%B0%92%EC%9D%B4%20%EC%A0%84%EB%8B%AC%EB%90%98%EB%8A%94%20%EA%B3%BC%EC%A0%95.png)
    
    - num1, num2는 main()함수의 변수입니다. add(num1, num2)로 사용하면 add()함수에 두 값을 넘겨줄 수 있습니다.
    - 매개변수 n1, n2는 실제 함수로 넘어온 두 값을 받아 주는 역할입니다. 다시 말해 n1, n2는 add()함수에서 선언한 새로운 변수입니다.
    - 따라서 함수를 호출할 때 사용하는 변수이름과 호출되는 함수에서 사용하는 변수는 서로 다른 변수이므로 이름이 같아도 되고 달라도 상관이 없습니다.
    
    ### 함수 호출과 스택 메모리
    
    - 함수를 호출하면 그 함수만을 위한 메모리 공간이 할당되는데, 이 메모리 공간을 스택(stack)이라고 부릅니다.
    
    ### add()함수를 호출하면 메모리를 생성하는 과정
    
    ![https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/%EC%8A%A4%ED%83%9D%EB%A9%94%EB%AA%A8%EB%A6%AC1.png](https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/%EC%8A%A4%ED%83%9D%EB%A9%94%EB%AA%A8%EB%A6%AC1.png)
    
    ### add()함수 수행이 끝나고 함수에 할당했던 메모리 공간을 해제하는 과정
    
    ![https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/%EC%8A%A4%ED%83%9D%EB%A9%94%EB%AA%A8%EB%A6%AC2.png](https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/%EC%8A%A4%ED%83%9D%EB%A9%94%EB%AA%A8%EB%A6%AC2.png)
    
    ### 함수의 장점
    
    - 기능을 나누어 코드를 효율적으로 구현할 수 있다.
    - 기능을 분리해서 구현하면 프로그램 코드의 가독성이 좋아진다.
    - 기능별로 함수를 구현해 놓고 같은 기능을 매번 코드로 만들지 않고 그 기능의 함수를 편리하게 호출할 수 있다.(중복되는 코드를 막을 수 있다.)
    - 디버깅 작업을 할 때도 편리하다.(하나의 기능이 하나의 함수로 구현되어 있기 때문에 오류난 기능만 찾아서 수정하면 된다.)
    
    ### 클래스 기능을 구현하는 메서드
    
    - 메서드(method)는 멤버변수를 사용하여 클래스의 기능을 구현한다.
    - 즉, 메서드는 함수에 객체 지향개념이 포함된 용어로 이해하면 된다.
    - 함수의 스택 메모리 사용방법과 함수의 장점등도 모두 메서드에 동일하게 적용된다.
    
    ```java
    public class Student {
    	int studentID; // 학번
    	String studentName; // 학생이름
    	int grade; // 학년
    	String address; // 사는 곳
    
    	// 학생의 이름을 반환하는 메서드
    	public String getStudentName() {
    		return studentName;
    	}
    
    	// 학생의 이름을 부여하는 메서드
    	public void setStudentName(String name) {
    		studentName = name;
    	}
    
    	public void showStudentInfo() {
    		System.out.println(studentName + "," + address); // 이름, 주소 출력
    	}
    }
    
    ```
    

## 클래스와 인스턴스

- 설명
    
    ### 클래스 사용과 main(), 함수
    
    ```java
    public class Student {
    	int studentID;
    	String studentName;
    	int grade;
    	String address;
    
    	public String getStudentName() {
    		return studentName;
    	}
    
    	public void setStudentName(String name) {
    		studentName = name;
    	}
    }
    
    ```
    
    - 멤버변수는 클래스 속성을 나타냅니다.
    - 메서드는 멤버변수를 이용하여 클래스 기능을 구현합니다.
    
    ### 프로그램을 시작하는 main()함수
    
    - main() 함수는 자바 가상 머신(Java Virtual Machine:JVM)이 프로그램을 시작하기 위해 호출하는 함수입니다.
    - 클래스 내부에 만들지만, 클래스의 메서드는 아닙니다.
    
    ### main()함수에서 클래스를 사용하는 방법
    
    - 클래스 내부에 main함수를 만드는 것
    
    ```java
    public class Student {
    	int studentID;
    	String studentName;
    	int grade;
    	String address;
    
    	public String getStudentName() {
    		return studentName;
    	}
    
    	public void setStudentName(String name) {
    		studentName = name;
    	}
    
    	// main() 함수
    	public static void main(String[] args) {
    		Student studentAhn = new Student(); // Student 클래스 생성
    		studentAhn.studentName = "안연수";
    
    		System.out.println(studentAhn.studentName);
    		System.out.println(studentAhn.getStudentName());
    	}
    }
    
    ```
    
    - 외부에 테스트용 클래스를 만들어 사용하는 것
    
    ```java
    public class StudentTest {
    	public static void main(String[] args) {
    		Student studentAhn = new Student(); // Student 클래스 생성
    		studentAhn.studentName = "안승연";
    
    		System.out.println(studentAhn.studentName);
    		System.out.println(studentAhn.getStudentName());
    	}
    }
    
    ```
    
    - 클래스 내부에 main()함수를 만들면 이 클래스가 프로그램의 시작 클래스가 됩니다.
    
    > 만약 패키지가 다르다면 import문을 사용해서 함께 사용하기를 원하는 클래스를 불러와야 한다. 클래스 이름이 같아도 패키지가 다르면 다른클래스이다.
    > 
    > 
    > Student라는 같은 이름의 두 클래스를 하나의 패키지에 구현하면 같은 이름의 클래스가 존재한다고 오류가 날 것입니다. 하지만 패키지가 다르면 문제가 되지 않습니다. 왜냐하면 aaa패키지 하위의 Student 클래스의 실제 이름은 aaa.Student이고, bbb패키지 하위의 Student 클래스의 실제 이름은 bbb.Student이기 때문입니다. 이를 클래스 전체 이름(class full name)이라고 합니다. 따라서 패키지가 다르면 클래스 이름이 같아도 다른 클래스입니다.
    > 
    
    ### new 예약어로 클래스 생성하기
    
    - 클래스를 사용하려면 먼저 클래스를 생성해야 합니다.
    
    ```java
    // 클래스형 변수이름 = new 생성자;
    Student studentAhn = new Student();
    //        참조변수         인스턴스 생성
    
    ```
    
    [생성자 참조](https://github.com/yonggyo1125/curriculum300H/tree/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1#%EC%83%9D%EC%84%B1%EC%9E%90)
    
    - 클래스가 생성된다는 것은 클래스를 실제 사용할 수 있도록 메모리 공간(힙 메모리)을 할당 받는다는 뜻입니다.
    - 이렇게 실제로 사용할 수 있도록 생성된 클래스를 **인스턴스**라고 합니다.
    - 그리고 인스턴스를 가리키는 클래스형 변수를 **참조변수**라고 합니다.
    
    ### 객체, 클래스, 인스턴스
    
    - **객체**란 '의사나 행위가 미치는 대상'이며 이를 코드로 구현한 것이 **클래스**입니다.
    - 클래스가 메모리 공간에 생성된 상태를 **인스턴스**라고 합니다.
    - 또한 **생성된 클래스의 인스턴스**를 **객체**라고도 합니다.
    
    - 클래스의 생성자를 호출하면 인스턴스가 만들어집니다.
    - **클래스는 하나**이지만, 이 클래스로부터 **여려 개의 각기 다른 인스턴스를 생성**할 수 있습니다.
    
    ### 인스턴스 여러개 생성하기
    
    ```java
    public class StudentTest1 {
    	public static void main(String[] args) {
    
    		Student student1 = new Student();  // 첫 번째 학생 생성
    		student1.studentName = "안연수";
    		System.out.println(student1.getStudentName());
    
    		Student student2 = new Student();  // 두 번째 학생 생성
    		student2.studentName = "안승연";
    		System.out.println(student2.getStudentName());
    	}
    }
    
    //실행결과
    //안연수
    //안승연
    ```
    
    ### 참조변수 사용하기( ↑ )
    
    - 참조변수를 사용하면 인스턴스의 멤버변수와 메서드를 참조하여 사용할 수 있는데 이때 마침표(.)연산자를 사용합니다.
    
    ### 인스턴스와 힙 메모리( ↑ )
    
    - 스택 메모리 ( 지역변수 : 주소 ) → 힙 메모리 ( 인스턴스 )
    - 생성된 두 인스턴스는 당연히 각각 다른 메모리 공간을 차지합니다.
        
        따라서 student1.studentName과 student2.studentName은 서로 다른 값을 가지게 됩니다.
        
    
    ![https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/%ED%9E%99%EB%A9%94%EB%AA%A8%EB%A6%AC2.png](https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/%ED%9E%99%EB%A9%94%EB%AA%A8%EB%A6%AC2.png)
    
    - 이런 이유 때문에 클래스에 선언한 멤버변수를 다른말로 **인스턴스 변수**라고 합니다.
    
    ### 힙 메모리란?
    
    힙(heap)은 프로그램에서 사용하는 동적 메모리(dynamic memory) 공간을 말합니다. 일반적으로 프로그램은 **스택, 힙, 데이터** 이렇게 세 영역을 사용해야 하는데, **객체가 생성될 때 사용하는 공간이 힙**입니다. 힙은 동적으로 할당되며 사용이 끝나면 메모리를 해제해 주어야 합니다. C나 C++ 언어에서는 프로그래머가 직접 메모리를 해제해야 하지만 자바에서는 가비지 콜렉터(garbage collector)가 자동으로 메모리를 해제해줍니다.
    
    ### 참조 변수와 참조 값
    
    - 참조 변수는 힙 메모리에 생성된 인스턴스를 가리킵니다.
    - 힙 메모리에 생성된 인스턴스의 메모리 주소는 참조 변수에 저장됩니다.
    - 출력 내용은 **클래스 이름@주소 값** 입니다.
    - 여기에 나오는 주소 값은 다른 말로 **해시 코드(hash code) 값**이라고도 합니다.
    - 이 값은 자바 가상 머신에서 객체가 생성되었을 때 생성된 객체에 할당하는 **가상 주소 값**입니다.
    - 따라서 student1변수를 사용하여 student1 인스턴스를 참조할 수 있습니다.
    - 이때 student1을 **참조 변수**, 주소 값을 **참조 값**이라고 합니다.

## 생성자

- 설명
    
    ```java
    public class Person {
    	String name;
    	float height;
    	float weight;
    }
    ```
    
    ```java
    public class PersonTest {
    	public static void main(String[] args) {
    		Person personLee = new Person(); // Person()  - 생성자
    	}
    }
    ```
    
    - 클래스를 생성할 때 사용하는 Person()과 같은 함수를 **생성자**라고 합니다.
    - 생성자가 하는 역할은 인스턴스의 생성과 인스턴스를 생성할 때 멤버 변수나 상수를 초기화하는 것입니다.
    
    ### 디폴트 생성자
    
    ```java
    public class Person {
    	String name;
    	float height;
    	float weight;
    
    	/*
    	다른 생성자가 없을 시에만 자바 컴파일러가 자동으로 제공하는 디폴트 생성자
    	클래스의 이름으로.
    	클래스 생성 시 사용
    	매개변수 X, 구현코드 X, 반환값 X	
    	*/
    	public Person() {}
    }
    ```
    
    ### 생성자 만들기
    
    - 생성자는 주로 멤버변수에 대한 값들을 매개변수로 받아서 인스턴스가 새로 생성될 때 멤버 변수 값들을 초기화하는 역할을 합니다.
    - 즉, 인스턴스가 생성됨과 동시에 멤버변수의 값을 지정하고 인스턴스를 초기화하기 위해 생성자를 직접 구현하여 사용합니다.
    
    ```java
    public class Person {
    	String name;
    	float height;
    	float weight;
    
    	/**
    	 * 사람 이름을 매개변수로 입력받아서
    	 * Person 클래스를 생성하는 생성자
    	 */
    	public Person(String pname) {
    		name = pname;
    	}
    }
    ```
    
    ```java
    public class PersonTest {
    	public static void main(String[] args) {
    		Person personLee = new Person(); // 오류 발생 - 디폴트 생성자 없어서
    	}
    }
    ```
    
    - 오류를 없애려면 **매개변수가 있는 생성자로 호출**하거나 프로그래머가 **디폴트 생성자를 추가**로 직접 구현하면 됩니다.
    
    ### 생성자 오버로드
    
    - 클래스에서 생성자가 두개 이상 제공되는 경우를 **생성자 오버로드**(constructor overload) 합니다.
    
    > 객체지향 프로그램에서 메서드 이름이 같고 매개변수만 다른 경우를 오버로드라고 합니다.
    > 
    
    ```java
    public class Person {
    	String name;
    	float height;
    	float weight;
    
    	public Person() {} // 디폴트 생성자 직접 추가
    
    	/**
    	 * 사람 이름을 매개변수로 입력받아서
    	 * Person 클래스를 생성하는 생성자
    	 */
    	public Person(String pname) {
    		name = pname;
    	}
    
    	//이름 키, 몸무게를 매개변수로 입력받는 생성자
    	public Person(String pname, float pheight, float pweight) {
    		name = pname;
    		height = pheight;
    		weight = pweight;
    	}
    }
    ```
    
    ```java
    public class PersonTest2 {
    	public static void main(String[] args) {
    		Person personKim = new Person();
    		personKim.name = "김유신";
    		personKim.weight = 85.5f;
    		personKim.height = 180.0f;
    
    		Person personLee = new Person("이순신", 175, 75);
    	}
    }
    ```
    

## 참조 자료형

- 설명
    
    크기가 정해진 기본 자료형(int, char, float, double 등)으로 선언하는 변수가 있고, 클래스형으로 선언하는 참조 자료형 변수가 있다.
    
    ```java
    public class Subject {
    	String subjectName;
    	int scorePoint;
    }
    ```
    
    ```java
    public class Subject3 {
    	int studentID;
    	String studentName;
    
    	// Subject 참조 자료형을 사용하여 선언
    	Subject korean;
    	Subject math;
    }
    ```
    
    - 기본자료형 : int studentID
    - 참조자료형 : String studentgName, Subject korean, Subject math

## 정보 은닉

- **접근 제어자**(access modifier)
    - 객체 지향 프로그램에서는 예약어를 사용해 클래스 내부의 변수나 메서드, 생성자에 대한 접근 권한을 지정할 수 있습니다.
    - 이러한 예약어를 '**접근 제어자**(access modifier)'라고 합니다.
    
    ### 접근제어자 정리
    
    | 접근 제어자 | 클래스 | 패키지 | 상속 | 외부 |
    | --- | --- | --- | --- | --- |
    | public | o | o | o | o |
    | protected | o | o | o | x |
    | 아무것도 없는 경우 (default)x | o | o | x | x |
    | private | o | x | x | x |
    
    ### private 사용하기
    
    ```java
    public class Student {
    	int studentID;
    	// studentName 변수를 private으로 선언
    	private String studentName;
    	int grade;
    	String address;
    }
    
    ```
    
    ### private 사용하기
    
    ```java
    public class StudentTest {
    	public static void main(String[] args) {
    		Student studentLee = new Student();
    		studentLee.studentName = "이상원"; // 오류발생
    	}
    }
    ```
    
    - StudentTest.java파일에 오류가 발생합니다.
    - studentName 변수의 접근 제어자가 public일 때는 외부 클래스인 StudentTest.java 클래스에서 이 변수에 접근할 수 있었지만, private으로 바뀌면서 외부 클래스의 접근이 허용되지 않기 때문입니다.
    
    ### get(), set() 메서드
    
    - private으로 선언한 studentName 변수를 외부 코드에서 사용하려면?
        - public 메서드가 제공되지 않는다면 studentName 변수에 접근할 수 있는 방법은 없습니다.
        - 이때 사용할 수 있는 것이 get(), set()메서드 입니다.
            
            > 값을 받는 get() 메서드를 getter, 값을 지정하는 set()메서드를 setter라고도 부릅니다.
            > 
    
    ```java
    public class Student {
    	int studentID;
    	// studentName 변수를 private으로 선언
    	private String studentName;
    	int grade;
    	String address;
    
    	public String getStudentName() {
    		return studentName;
    	}
    
    	public void setStudentName(String studentName) {
    		this.studentName = studentName;
    	}
    }
    ```
    
    ```java
    public class StudentTest {
    	public static void main(String[] args) {
    		Student studentLee = new Student();
    		//studentLee.studentName = "이상원"; // 오류발생
    
    		// setStudentName() 메서드 활용해 private 변수에 접근 가능
    		studentLee.setStudentName("이상원");
    
    		System.out.println(studentLee.getStudentName());
    	}
    }
    ```
    
    ### 정보 은닉이란?
    
    - 클래스의 멤버 변수를 public으로 선언하면 접근이 제한되지 않으므로 정보의 오류가 발생할 수 있습니다.
        
        
        ```java
        public class MyDate {
        		public int day;
        		public int month;
        		public int year;
        }
        ```
        
    - 이런 경우 오류가 나더라도 그 값이 해당 변수에 대입되지 못하도록 다음과 같이 변수를 private으로 바꾸고 public 메서드를 별도로 제공해야 합니다.
        
        
        ```java
        public class MyDateTest {
        		public static void main(String[] args) {
        				MyDate date = new MyDate();
        				date.month = 2;
        				date.day = 31;
        				date.year = 2018;
        		}
        }
        ```
        
    - 이처럼 클래스 내부에서 사용할 변수나 메서서드는 private으로 선언해서 외부에서 접근하지 못하도록 하는 것을 객체 지향에서는 '**정보은닉**(information hiding)'이라고 합니다.
    
    ```java
    public class MyDate2 {
    		private int day;
    		private int month;
    		private int year;
    
    		public void setDay(int day) {
    				if (month == 2) {
    						if (day < 1 || day > 28) {
    								System.out.println("오류입니다.");
    						} else {
    								this.day = day;
    						}
    				}
    		}
    }
    ```
    
    ```java
    public class MyDateTest2 {
    		public static void main(String[] args) {
    				MyDate2 date = new MyDate2();
    		
    				date.setYear(2018);
    				date.setMonth(2);
    				date.setDay(31);
    		}
    }
    ```
    
    - 정보은닉은 객체지향 프로그래밍의 특징 중에 하나이며 자바에서는 접근 제어자를 사용하여 정보은닉을 구현합니다.
    - 모든 변수를 private으로 선언해야 하는 것은 아니지만, 필요한 경우에는 private으로 선언하여 오류를 막을 수 있습니다.

## this 예약어

- 자신의 메모리를 가리키는 this
    - this는 생성된 인스턴스 스스로를 가리키는 예약어입니다.
    
    ```java
    class BirthDay {
    	int day;
    	int month;
    	int year;
    
    	public void setYear(int year) {
    		this.year = year;  // bDay.year = year;와 같음
    	}
    
    	public void printThis( ) {
    		System.out.println(this); // System.out.println(bDay);와 같음
    	}
    }
    
    public class ThisExample {
    	public static void main(String[] args) {
    		BirthDay bDay = new BirthDay();
    		bDay.setYear(2000);
    		System.out.println(bDay);
    		bDay.printThis();
    	}
    }
    // 실행결과
    
    // day05_07.thisex.BirthDay@5e91993f
    // day05_07.thisex.BirthDay@5e91993f
    ```
    
    - 인스턴스를 가리키는 변수가 참조변수 이며, 참조변수를 출력하면 '**클래스 이름@메모리 주소**' 문자열 값이 나옵니다.
    - 출력 결과를 보면 bDay.printThis()메서드를 호출하여 출력한 this 값이 참조 변수 bDay를 출력한 값과 같습니다.
    - 즉, 클래스 코드에서 사용하는 **this**는 **생성된 인스턴스 자신**을 가리키는 역할을 합니다.
    - this.year = year; 문장으로 참조하면 **동적메모리에서 생성된 인스턴스 year 변수 위치를 가리키고 그 위치에 매개변수 값을 넣어 주는 것**입니다.
    
    ![https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/this_1.png](https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/this_1.png)
    
    - 위 그림에서 main() 함수는 ThisExample 클래스의 시작 메서드 입니다.
    - 그림을 보면 main() 함수에서 bDay 변수가 가리키는 인스턴스와 BirthDay 클래스의 setYear()메서드에서 this가 가리키는 인스턴스가 같은 곳에 있음을 알 수 있습니다.
    
    ### 생성자에서 다른 생성자를 호출하는 this
    
    - this를 사용해 클래스의 생성자에서 다른 생성자를 호출할 수 있습니다.
    
    ```java
    class Person {
    	String name;
    	int age;
    
    	Person() {
    		this("이름 없음", 1);  // this를 사용해 Person(String, int) 생성자 호출
    	}
    
    	Person(String name, int age) {
    		this.name = name;
    		this.age = age;
    	}
    }
    
    public class CallAnotherConst {
    	public static void main(String[] args) {
    		Person noName = new Person();
    		System.out.println(noName.name);
    		System.out.println(noName.age);
    	}
    }
    
    // 실행결과
    // 이름 없음
    // 1
    ```
    
    - this를 사용하여 생성자를 호출하는 코드 이전에 다른 코드를 넣을 수 없습니다. 만약 다른 코드를 넣으면 오류가 발생합니다.
        - 생성자는 클래스가 생성될 때 호출되므로 클래스 생성이 완료되지 않은 시점에 다른 코드가 있다면 오류가 발생할 수 있습니다.
    - 즉, 디폴드 생성자에서 생성이 완료되는 것이 아니라 this를 사용해 다른 생성자를 호출하므로 이때는 this를 활용한 문장이 가장 먼저 와야 합니다.
    
    ### 자신의 주소를 반환하는 this
    
    - this를 사용하여 생성된 클래스 자신의 주소 값을 반환할 수 있습니다.
    - 인스턴스 주소 값을 반환할 때는 this를 사용하고 반환형은 클래스 자료형을 사용합니다.
    
    ```java
    class Person {
    	String name;
    	int age;
    
    	Person() {
    		this("이름 없음", 1);  // this를 사용해 Person(String, int) 생성자 호출
    	}
    
    	Person(String name, int age) {
    		this.name = name;
    		this.age = age;
    	}
    
    	// 반환받은 클래스형
    	Person returnItSelf() {
    		return this; // this 반환
    	}
    }
    
    public class CallAnotherConst {
    	public static void main(String[] args) {
    		Person noName = new Person();
    		System.out.println(noName.name);
    		System.out.println(noName.age);
    
    		Person p = noName.returnItSelf(); // this 값을 클래스 변수에 대입
    		System.out.println(p);	// noName.returnItSelf()의 반환 값 출력
    		System.out.println(noName); // 참조변수 출력
    	}
    }
    
    // 실행결과
    
    // 이름 없음
    // 1
    // day05_07.thisex.Person@5e91993f
    // day05_07.thisex.Person@5e91993f
    
    ```
    

## static 변수

- 변수를 여러 클래스에서 공통으로 사용하려면?
    
    클래스에서 공통적으로 사용하는 변수를 'static 변수'로 선언합니다.
    
    ### static 변수의 정의와 사용방법
    
    - static 변수 ( **정적변수 )**
        
        ```java
        static 자료형 변수명;
        ```
        
    - static 변수는 클래스 내부에 선언하지만, 다른 멤버 변수처럼 인스턴스가 생성될 때마다 새로 생성되는 변수가 아닙니다.
    - static 변수는 프로그램이 실행되어 메모리에 올라갔을 때 딱 한번 메모리 공간에 할당됩니다.
        
        ### 그리고 그 값은 모든 인스턴스가 공유합니다.
        
    - 이런 이유 때문에 static 변수를 클래스에 기반한 변수라고 해서 **클래스 변수**(class variable)라고도 합니다.
    
    ### static 변수를 사용 문제
    
    ```java
    public class Student {
    	// static 변수는 인스턴스 생성과 상관없이 먼저 생성됨
    	public static int serialNum = 1000;
    	public int studentID;
    	public String studentName;
    	public int grade;
    	public String address;
    
    	public String getStudentName() {
    		return studentName;
    	}
    
    	public void setStudentName(String name) {
    		studentName = name;
    	}
    }
    ```
    
    ### 
    
    ```java
    public class StudentTest1 {
    	public static void main(String[] args) {
    		Student studentLee = new Student();
    		studentLee.setStudentName("이지원");
    		System.out.println(studentLee.serialNum); // serialNum 변수의 초깃값 출력
    		studentLee.serialNum++; // static 변수 값 증가
    
    		Student studentSon = new Student();
    		studentSon.setStudentName("손수경");
    		System.out.println(studentSon.serialNum);  //증가된 값 출력
    		System.out.println(studentLee.serialNum); // 증가된 값 출력
    	}
    }
    
    // 실행결과
    // 1000
    // 1001
    // 1001
    ```
    
    ![https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/static3.png](https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA(84%EC%8B%9C%EA%B0%84)/5~7%EC%9D%BC%EC%B0%A8(9h)%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D1/images/static3.png)
    
    - static변수는 모든 인스턴스가 공유하는 변수이므로 이 변수를 바로 학번으로 사용하면 모든 학생이 동일한 학번 값을 가지게 되므로 학생 고유 번호로써 학번으로 활용할 수 없습니다.
    - 학번은 학생의 고유 번호 이므로 학생의 멤버변수로 선언해 주고, 학생이 한 명 생성될 때마다 증가한 serialNum 값을 studentID에 대입해 주면 이 문제를 해결할 수 있습니다.
    
    ### 
    
    ```java
    public class Student1 {
    	public static int serialNum = 1000;
    	public int studentID;
    	public String studentName;
    	public int grade;
    	public String address;
    
    	public Student1() {
    		serialNum++; // 학생이 생성될 때마다 증가
    		studentID = serialNum;  // 증가된 값을 학번 인스턴스 변수에 부여
    														// 시퀀스처럼 사용
    	}
    
    	public String getStudentName() {
    		return studentName;
    	}
    
    	public void setStudentName(String name) {
    		studentName = name;
    	}
    }
    
    ```
    
    ### 
    
    ```java
    public class StudentTest2 {
    	public static void main(String[] args) {
    		Student1 studentLee = new Student1();
    		studentLee.setStudentName("이지원");
    		System.out.println(studentLee.serialNum);
    		System.out.println(studentLee.studentName + " 학번:" + studentLee.studentID);
    
    		Student1 studentSon = new Student1();
    		studentSon.setStudentName("손수경");
    		System.out.println(studentSon.serialNum);
    		System.out.println(studentSon.studentName + " 학번:" + studentSon.studentID);
    	}
    }
    
    //실행결과
    
    // 1001
    // 이지원 학번:1001
    // 1002
    // 손수경 학번:1002
    
    ```
    
    ### 클래스 변수
    
    - static 변수는 인스턴스를 생성할 때마다 만들어지는 것이 아니고 클래스를 선언할 때 특정 메모리에 저장되어 모든 인스턴스가 공유하는 변수입니다.
    - 클래스 이름으로도 참조하여 사용할 수 있다.
        
        →  **클래스 변수**라고도 합니다.
        
    
    ### 
    
    ```java
    public class StudentTest3 {
    	public static void main(String[] args) {
    		Student1 studentLee = new Student1();
    		studentLee.setStudentName("이지원");
    		System.out.println(Student1.serialNum); // serialNum 변수를 직접 클래스 이름으로 참조
    		System.out.println(studentLee.studentName + " 학번:" + studentLee.studentID);
    
    		Student1 studentSon = new Student1();
    		studentSon.setStudentName("손수경");
    		System.out.println(Student1.serialNum);  // serialNum 변수를 직접 클래스 이름으로 참조
    		System.out.println(studentSon.studentName + " 학번:" + studentSon.studentID);
    	}
    }
    
    ```
    
    ### 클래스 메서드
    
    - static 변수를 위한 메서드
    - 이런 메서드를 **static메서드** 또는 **클래스 메서드**라고 합니다.
    
    ### 
    
    ```java
    public class Student2 {
    	private static int serialNum = 1000; // private 변수로 변경
    	public int studentID;
    	public String studentName;
    	public int grade;
    	public String address;
    
    	public Student2() {
    		serialNum++;
    		studentID = serialNum;
    	}
    
    	public String getStudentName() {
    		return studentName;
    	}
    
    	public void setStudentName(String name) {
    		studentName = name;
    	}
    
    	// serialNum의 get()메서드
    	public static int getSerialNum() {
    		int i = 10;
    		return serialNum;
    	}
    
    	// serialNum의 set()메서드
    	public static void setSerialNum(int serialNum) {
    		Student2.serialNum = serialNum;
    	}
    }
    
    ```
    
    ### 
    
    ```java
    public class StudentTest4 {
    	public static void main(String[] args) {
    		Student2 studentLee = new Student2();
    		studentLee.setStudentName("이지원");
    		// serialNum 값을 가져오기 위해 get()메서드를 클래스 이름으로 직접 호출
    		System.out.println(Student2.getSerialNum());
    		System.out.println(studentLee.studentName + " 학번:" + studentLee.studentID);
    
    		Student2 studentSon = new Student2();
    		studentSon.setStudentName("손수경");
    		// serialNum 값을 가져오기 위해 get()메서드를 클래스 이름으로 직접 호출
    		System.out.println(Student2.getSerialNum());
    		System.out.println(studentSon.studentName + " 학번:" + studentSon.studentID);
    	}
    }
    
    ```
    
    ### 클래스 메서드와 인스턴스 변수
    
    - 클래스 메서드 내부에서는 인스턴스 변수를 사용할 수 없습니다.
    - 마찬가지로 클래스 메서드 내부에서는 인스턴스 메서드 역시 사용할 수 없습니다.
    - 클래스 변수, 클래스 메서드는 인스턴스가 만들어지기 이전에 존해하므로 인스턴스에 접근할 수 없습니다.
    - 클래스 변수, 클래스 메서드는 인스턴스가 생성되지 않아도 사용할 수 있습니다.
    
    ```java
    public class Student2 {
    		// 클래스 변수
    		private static int serialNum = 1000; // private 변수로 변경
    		// 인스턴스 변수
    		public int studentID;
    		public String studentName;
    		public int grade;
    		public String address;
    
    			...
    		// 클래스 메서드
    		public static int getSerialNum() {
    				int i = 10;
    				studentName = "이지원"; // 오류발생
    				return serialNum;
    		}
    ```
    
    ### 
    
    ```java
    public class StudentTest5 {
    	public static void main(String[] args) {
    		// 인스턴스 생성 없이 호출 가능
    		System.out.println(Student2.getSerialNum());
    	}
    }
    // 실행결과
    // 1000
    ```
    

## 변수의 유효범위

- 설명
    
    ### 지역변수의 유효범위
    
    - 지역변수는 함수나 메서드 내부에 선언하기 때문에 함수 밖에서는 사용할 수 없습니다.
    - 스택에서 생성되는 지역변수는 함수가 호출될 때 생성되었다가 함수가 반환되면 할당되었던 메모리 공간이 해제되면서 함께 없어집니다.
    
    ### 멤버변수의 유효범위
    
    - 멤버변수는 인스턴스 변수라고도 합니다.
    - 클래스가 생성될 때 힙(heap)메모리에 생성되는 변수입니다.
    - 멤버변수는 클래스의 어느 메서드에서나 사용할 수 있습니다.
    - 힙에 생성된 인스턴스가 가비지 컬렉터(garbage collector)에 의해 수거되면 메모리에서 사라집니다.
    
    ### static 변수의 유효범위
    
    - 사용자가 프로그램을 실행하면 메모리 프로그램이 상주합니다.
    - 이때 프로그램 영역 중에 데이터 영역이 있습니다. 이 영역에는 상수나 문자열, static 변수가 생성됩니다.
    - static 변수는 클래스 생성과 상관 없이 데이터 영역 메모리에 생성됩니다.
    - 따라서 인스턴스 변수와 static 변수는 사용하는 메모리가 다릅니다.
    - static 변수는 private이 아니라면 클래스 외부에서도 객체생성과는 무관하게 사용할 수 있습니다.
    - 프로그램 실행이 끝난 뒤에 메모리에서 내려가면 static 변수도 소멸됩니다.
    - static 변수는 프로그램이 시작할 때 부터 끝날 때 까지 메모리에 상주하므로 크기가 너무 큰 변수를 static으로 선언하는것은 좋지 않습니다.

## static 응용 - 싱글톤 패턴

- 단 하나의 인스턴스
    - 프로그램을 구현하다 보면 여러개 인스턴스가 필요한 경우도 있고 단 하나의 인스턴스만 필요한 경우도 있습니다.
    - 객체 지향 프로그램에서 인스턴스를 단 하나만 생성하는 디자인 패턴을 **싱글톤 패턴**(singleton pattern)이라고 합니다.
    
    ### 싱글톤 패턴으로 회사 클래스 구현하기
    
    1. 생성자를 private으로 만들기
        - 생성자가 public 이면 외부에서 인스턴스를 여러개 생성할 수 있습니다.
        - 따라서 싱글톤 패턴에서는 생성자를 반드시 명시적으로 만들고 그 접근 제어자를 private으로 지정해야 합니다.
        - 그러면 생성자가 있으므로 컴파일러가 디폴트 생성자를 만들지 않고, 접근 제어자가 private이므로 외부 클래스에서 마음대로 Company 인스턴스를 생성할 수 없게 됩니다.
        - 즉, Company 클래스 내부에서만 클래스의 생성을 제어할 수 있습니다.
    2. 클래스 내부에 static으로 유일한 인스턴스 생성하기
        - private으로 선언하여 외부에서 이 인스턴스에 접근하지 못하도록 제한해야 합니다.
    3. 외부에서 참조 할 수 있는 public 메서드 만들기
        - private으로 선언한 유일한 인스턴스를 외부에서도 사용할 수 있도록 설정해야 합니다.
        - 이를 위해 public 메서드를 생성합니다. 그리고 유일하게 생성한 인스턴스를 반환해 줍니다.
        - 이 때 인스턴스를 반환하는 메서드는 반드시 static으로 선언해야 합니다.
        - 왜냐하면 인스턴스 생성과 상관없이 호출할 수 있어야 하기 때문입니다.
    
    ```java
    public class Company {
    
    	private static Company instance = new Company();  // static 변수로 선언, 유일
    
    	private Company() {}     // 객체 생성 막기 위해 생성자 private 설정
    
    	public static Company getInstance() {    // 객체생성 메서드 static으로 선언하여 
    																					// 클래스 객체로(유일 객체) 사용할 수 있도록.
    		if (instance == null) {
    			instance = new Company();
    		}
    
    		return instance;
    	}
    }
    
    ```
    
    ### 
    
    ```java
    public class CompanyTest {
    	public static void main(String[] args) {
    		// 클래스 이름으로 getInstance() 호출하여 참조 변수에 대입
    		Company myCompany1 = Company.getInstance();
    		Company myCompany2 = Company.getInstance();
    
    		System.out.println(myCompany1 == myCompany1); // 두 변수가 같은 주소인지 확인
    	}
    }
    // 실행결과
    // true
    ```
    

### 용어 정리

| 용어 | 설명 |
| --- | --- |
| 객체 | 객체 지향 프로그램의 대상, 생성된 인스턴스 |
| 클래스 | 객체를 프로그래밍 하기 위해 코드로 만든 상태 |
| 인스턴스 | 클래스가 메모리에 생성된 상태 |
| 멤버변수 | 클래스의 속성, 특징 |
| 메서드 | 멤버 변수를 이용하여 클래스의 기능을 구현 |
| 참조 변수 | 메모리에 생성된 인스턴스를 가리키는 변수 |
| 참조 값 | 생성된 인스턴스의 메모리 주소 값 |

### 자바의 이름 짓기 규약

- **클래스 이름** : 파스칼케이스 - 단어의 시작 문자는 모두 대문자, 예) OrderInfo, OrderItems
- **메서드 및 멤버변수** : 카멜케이스 - 첫 단어를 제외 단어의 시작문자는 대문자, 예) showStudentInfo
- **패키지 이름** : 모두 소문자
- **상수명** : 모두 대문자, 단어와 단어 사이는 언더바(_)로 구분, 예) NO_OF_STUDENT

</details>


## 다형성
<details>
- 하나의 코드가 여러 자료형으로 구현되어 실행되는 것
    
    ### 다형성이란?
    
    - 다형성이란 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 말합니다.
    
    > 다형성은 추상 클래스, 인터페이스에서 구현됩니다. 또한 안드로이드, 스트링 등 자바 기반의 프레임워크에서 응용할 수 있는 객체 지향 프로그래밍의 중요한 개념입니다.
    > 
    
    ```java
    package day08_10.polymorphism;
    
    class Animal {
    	public void move( ) {
    		System.out.println("동물이 움직입니다.");
    	}
    }
    
    class Human extends Animal {
    	public void move() {
    		System.out.println("사람이 두 발로 걷습니다.");
    	}
    }
    
    class Tiger extends Animal {
    	public void move() {
    		System.out.println("호랑이가 네 발로 뜁니다.");
    	}
    }
    
    class Eagle extends Animal {
    	public void move() {
    		System.out.println("독수리가 하늘을 납니다.");
    	}
    }
    
    public class AnimalTest1 {
    	public static void main(String[] args) {
    		AnimalTest1 aTest = new AnimalTest1();
    		aTest.moveAnimal(new Human());
    		aTest.moveAnimal(new Tiger());
    		aTest.moveAnimal(new Eagle());
    	}
    
    	public void moveAnimal(Animal animal) {
    		animal.move();
    	}
    }
    
    // 실행결과
    
    // 사람이 두 발로 걷습니다.
    // 호랑이가 네 발로 뜁니다.
    // 독수리가 하늘을 납니다.
    
    ```
    
    - animal.move() 코드는 변함이 없지만 어떤 매개변수가 넘어왔느냐에 따라 출력문이 달라집니다. 이것이 다형성 입니다.
    
    ### 다형성의 장점
    
    다형성을 활용한 프로그램의 확장성
    
    - 상위 클래스 - 공통 부분의 메서드를 제공, 
    하위 클래스 - 추가 요소를 덧붙여 구현하면
    → 코드 양도 줄어들고 유지보수도 편리합니다.
    - 필요에 따라 상속받은 모든 클래스를 하나의 상위 클래스로 처리할 수 있고, 
    다형성에 의해 각 클래스의 여러 가지 구현을 실행 할 수 있으므로 
    → 프로그램을 쉽게 확장할 수 있습니다.
    - 다형성을 잘 활용하면 유연하면서도 구조화된 코드를 구현하여 확장성 있고 유지보수하기 좋은 프로그램을 개발할 수 있습니다.
    
    ### 다형성을 활용해 VIP 고객 클래스 완성하기
    
    ```java
    package day08_10.polymorphism;
    
    public class Customer {
    	protected int customerID;
    	protected String customerName;
    	protected String customerGrade;
    	int bonusPoint;
    	double bonusRatio;
    
    	public Customer()
    	{
    		//  고객 등급과 보너스 포인트 적립률 지정 함수 호출
    		initCustomer();
    	}
    
    	public Customer(int customerID, String customerName){
    		this.customerID = customerID;
    		this.customerName = customerName;
    
    		// 고객 등급과 보너스 포인트 적립률 지정 함수 호출
    		initCustomer();
    	}
    
    	// 생성자에서만 호출하는 메서드이므로 private으로 선언
    	// 멤버 변수의 초기화 부분
    	private void initCustomer()
    	{
    		customerGrade = "SILVER";
    		bonusRatio = 0.01;
    	}
    
    	public int calcPrice(int price){
    		bonusPoint += price * bonusRatio;
    		return price;
    	}
    
    	public String showCustomerInfo(){
    		return customerName + " 님의 등급은 " + customerGrade + "이며, 보너스 포인트는 " + bonusPoint + "점입니다.";
    	}
    
    	public int getCustomerID() {
    		return customerID;
    	}
    
    	public void setCustomerID(int customerID) {
    		this.customerID = customerID;
    	}
    
    	public String getCustomerName() {
    		return customerName;
    	}
    
    	public void setCustomerName(String customerName) {
    		this.customerName = customerName;
    	}
    
    	public String getCustomerGrade() {
    		return customerGrade;
    	}
    
    	public void setCustomerGrade(String customerGrade) {
    		this.customerGrade = customerGrade;
    	}
    }
    ```
    
    - 기존 Customer 클래스와 달라진 점은 initCustomer() 메서드가 있습니다.
    - 이 메서드는 클래스의 멤버 변수를 초기화하는데, Customer 클래스를 생성하는 두 생성자에서 공통으로 사용하는 코드이므로 메서드로 분리하여 호출했습니다.
    
    ### 다형성을 활용해 VIP 고객 클래스 완성하기
    
    ```java
    package day08_10.polymorphism;
    
    public class VIPCustomer extends Customer {
    	private int agentID;
    	double saleRatio;
    
    	public VIPCustomer(int customerID, String customerName, int agentID){
    		super(customerID, customerName);
    
    		customerGrade = "VIP";
    		bonusRatio = 0.05;
    		saleRatio = 0.1;
    		this.agentID = agentID;
    	}
    
    	// 지불 가격 메서드 재정의
    	public int calcPrice(int price){
    		bonusPoint += price * bonusRatio;
    		return price - (int)(price * saleRatio);
    	}
    
    	// 고객 정보 출력 메서드 재정의
    	public String showCustomerInfo(){
    		return super.showCustomerInfo() + " 담당 상담원 번호는 " + agentID + "입니다";
    	}
    
    	public int getAgentID(){
    		return agentID;
    	}
    }
    
    ```
    
    - VIPCustomer 클래스에서 calcPrice() 메서드와 showCustomerInfo() 메서드를 재정의했습니다.
    - 일반 고객 클래스에서 calcPrice()메서드는 정가를 그대로 반환했지만, VIPCustomer 클래스에서는 할인율을 반영한 지불 가격을 반환합니다. 또 일반 고객 클래스에서, showCustomerInfo()메서드는 고객 등급과 이름만 출력했지만 VIPCustomer 클래스에서는 담당 상담원 번호까지 출력합니다.
    
    ### 
    
    ```java
    public class CustomerTest {
    	public static void main(String[] args) {
    		Customer customerLee = new Customer();
    		customerLee.setCustomerID(10010);
    		customerLee.setCustomerName("이순신");
    		customerLee.bonusPoint = 1000;
    		System.out.println(customerLee.showCustomerInfo());
    
    		// VIPCustomer를 Customer형으로 선언
    		Customer customerKim = new VIPCustomer(10020, "김유신", 12345);
    		customerKim.bonusPoint = 1000;
    		System.out.println(customerKim.showCustomerInfo());
    
    		System.out.println("====== 할인율과 보너스 포인트 계산 =======");
    
    		int price = 10000;
    		int leePrice = customerLee.calcPrice(price);
    		int kimPrice = customerKim.calcPrice(price);
    		System.out.println(customerLee.getCustomerName() +" 님이 " + leePrice + "원 지불하셨습니다.");
    		System.out.println(customerLee.showCustomerInfo());
    		System.out.println(customerKim.getCustomerName() +" 님이 " + kimPrice + "원 지불하셨습니다.");
    		System.out.println(customerKim.showCustomerInfo());
    	}
    }
    
    ```
    
    - 출력 결과를 보면 10,000원 짜라 상품을 구입했을 때 등급에 따라 다른 할인율과 포인트 적립이 이루어지는 것을 알 수 있습니다.
    - 그런데 여기에서 customerLee와 customerKim은 모두 Customer형으로 선언되었고, 고객의 자료형은 Customer형으로 동일하지만 할인율과 보너스 포인트는 각 인스턴스의 메서드에 맞게 계산되었습니다.
    - 즉, 상속 관계에 있는 상위 클래스와 하위 클래스는 같은 상위 클래스 자료형으로 선언되어 생성할 수 있지만 재정의된 메서드는 각각 호출될 뿐만 아니라 이름이 같은 메서드가 서로 다른 역할을 구현하고 있음을 알 수 있습니다.

## 다운 캐스팅과 instanceof

- 강제형변환, 자료형 확인
    
    ### 하위 클래스로 형 변환, 다운 캐스팅
    
    - 위와 같은 계층 구조에서 상위 클래스를 자료형으로 선언하는 Animal ani = new Human(); 코드를 쓸 수 있습니다.
    - 이때 생성된 인스턴스 Human은 Animal형 입니다. 이렇게 Animal형으로 형 변환이 이루어진 경우에는 Animal 클래스에서 선언한 메서드와 멤버 변수만 사용할 수 있습니다.
    - 다시 말해 Human 클래스에 더 많은 메서드가 구현되어 있고 다양한 멤버 변수가 있다고 하더라도 자료형이 Animal형인 상태에서는 사용할 수가 없습니다. 따라서 필요에 따라 다시 원래 인스턴스의 자료형(여기에서는 Human 형)으로 되돌아가야 하는 경우가 있습니다. 이렇게 상위 클래스로 형 변환 되었던 하위 클래스를 다시 원해 자료형으로 형 변환하는 것을 다운 캐스팅(down casting)이라고 합니다.
    
    ### instanceof
    
    - 상속 관계를 생각해보면 모든 인간은 동물이지만 모든 동물이 인간은 아닙니다. 따라서 다운 캐스팅을 하기 전에 상위 클래스로 형 변환된 인스턴스의 원래 자료형을 확인해야 변환할 때 오류를 막을 수 있습니다.
    - 이를 확인하는 예약어가 바로 instanceof입니다.
    
    ```java
    Animal hAnimal = new Human();
    if (hAnimal instanceof Human) { // hAnimal 인스턴스 자료형이 Human형이라면
    	Human human = (Human)hAnimal; // 인스턴스 hAnimal을 Human형으로 다운 캐스팅
    }
    
    ```
    
    - instanceof 예약어는 왼쪽에 있는 변수의 원래 인스턴스형이 오른쪽 클래스 자료형인가를 확인합니다.
    - instanceof의 반환 값이 true이면 다운 캐스팅을 하는데, 이때는 Human human = (Human)hAnimal; 문장과 같이 명시적으로 자료형을 써 주어야 합니다.
    - 상위 클래스로는 묵시적으로 형 변환이 되지만, 하위 클래스로 형 변환을 할 떄는 명시적으로 해야 합니다.
    - 만약 instanceof로 인스턴스형을 확인하지 않으면 오류가 발생할 수 있습니다.
    - 참조 변수의 원래 인스턴스형을 정확히 확인하고 다운 캐스팅을 해야 안전하며 이때 instanceof를 사용합니다.
    
    ### day08_10/polymorphism/AnimalTest.java
    
    ```java
    package day08_10.polymorphism.instance_of;
    
    import java.util.ArrayList;
    
    class Animal{
    	public void move()
    	{
    		System.out.println("동물이 움직입니다.");
    	}
    }
    
    class Human extends Animal{
    	public void move()
    	{
    		System.out.println("사람이 두 발로 걷습니다. ");
    	}
    
    	public void readBook()
    	{
    		System.out.println("사람이 책을 읽습니다. ");
    	}
    }
    
    class Tiger extends Animal{
    	public void move()
    	{
    		System.out.println("호랑이가 네 발로 뜁니다. ");
    	}
    
    	public void hunting()
    	{
    		System.out.println("호랑이가 사냥을 합니다. ");
    	}
    }
    
    class Eagle extends Animal{
    	public void move()
    	{
    		System.out.println("독수리가 하늘을 납니다 ");
    	}
    
    	public void flying()
    	{
    		System.out.print("독수리가 날개를 쭉 펴고 멀리 날아갑니다");
    	}
    }
    
    public class AnimalTest {
    	ArrayList<Animal> aniList = new ArrayList<Animal>();
    
    	public static void main(String[] args) {
    		AnimalTest aTest = new AnimalTest();
    		aTest.addAnimal();
    		System.out.println("원래 타입으로 다운 캐스팅 ");
    		aTest.testCasting();
    
    	}
    
    	public void addAnimal()
    	{
    		aniList.add(new Human());    //ArrayList에 추가되면서 Animal형으로 형 변환
    		aniList.add(new Tiger());
    		aniList.add(new Eagle());
    
    		for(Animal ani : aniList){     // 배열의 요소들을 Animal형으로 꺼내서 move 호출하면
    			ani.move();              // 오버라이딩(재정의)된 함수가 호출 됨
    		}
    	}
    
    	public void testCasting()
    	{
    		for(int i=0; i<aniList.size(); i++){  //모든 배열 항목들을 하나씩 돌면서
    
    			Animal ani = aniList.get(i);        // 일단 Shape 타입으로 가져옴
    			if(ani instanceof Human){       //Circle이면
    				Human h = (Human)ani;      //Circle형으로 다운 캐스팅
    				h.readBook();
    			}
    			else if(ani instanceof Tiger){
    				Tiger t = (Tiger)ani;
    				t.hunting();
    			}
    			else if(ani instanceof Eagle){
    				Eagle e = (Eagle)ani;
    				e.flying();
    			}
    			else{
    				System.out.println("지원되지 않는 타입입니다.");
    			}
    		}
    	}
    }
    
    //실행결과
    /*
    	사람이 두 발로 걷습니다.
    	호랑이가 네 발로 뜁니다.
    	독수리가 하늘을 납니다
    	원래 타입으로 다운 캐스팅
    	사람이 책을 읽습니다.
    	호랑이가 사냥을 합니다.
    	독수리가 날개를 쭉 펴고 멀리 날아갑니다
    */
    
    ```
    </details>