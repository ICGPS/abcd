# 1.고원일

## 웹기초 : 요청과 응답 이해하기
<details>
둘다 내장 객체의 종류 : 내장객체는 별도의 객체 생성 없이 각 내장 객체의 메서드를 사용할 수 있음 메이븐 레파지토리 API 문서가 이에 해당

요청은 request : 클라이언트의 요청 정보를 저장하는 역할, 웹 브라우저가 웹 서버에 웹 페이지를 달라고 하는 것

응답은 response : 클라이언트의 요청에 대한 응답 정보를 저장하는 역할, 웹 브라우저가 요청한 웹 페이지를 웹 브라우저에 제공하는 것

요청(request )은 JSP에서 가장 많이 사용됨 클라이언트가 전송한 요청 정보를 담고 있음

	<li>데이터 정송 방식 : <%=request.getMethod() %></li>
	<li>URL : <%=request.getRequestURL() %></li>
	<li>프로토콜 : <%=request.getProtocol() %></li>
	<li>서버이름 : <%=request.getServerName() %></li>
	<li>포트번호 : <%=request.getServerPort() %></li>
	<li>클라이언트 IP : <%=request.getRemoteAddr() %></li>
	<li>쿼리스트링 : <%=request.getQueryString() %></li>
	<li>파마미터 : <%=request.getParameter("eng") %></li>
	<li>파마미터 : <%=request.getParameter("han") %></li>
​
응답(response)는 요청에 의한 매개변수를 얻어와 내용을 처리하고 응답하는 역할 만약 클라이언트가 아이디와 비밀번호를 입력하여 정보를 받아 정보 일치 여부에 따른 뷰(JSP)로 이동하여 클라이언트에게 정보를 전달 또는 클라이언트의 정보를 저장하는 역할이라 보면된다.


	
	<% String id = request.getParameter("id");
	String pw = request.getParameter("pw");

     if("momo".equals(id) && "1234".equals(pw)){
	response.sendRedirect	("Welcome.jsp?id" + request.getParameter("id"));
​</details>
## 스프링 : DI란?
<details>
DI (Dependency 의존 Injection 주입)
이 단어를 이해하기 위해 의존을 먼저 이해해야한다.

쉽게 말해 꼬꼬무라고 이해하면 될 듯함. 

학원이 있으면 학원의 직원이 있고 그 직원과 강사 그리고 학생과 연결되어 있는 것 처럼 학원이라는 큰 컨테이너 안에 객체가 있고 서로 의존하고 있다고 생각하면 될 것 같음.

@Autowired 어노테이션을 이용해서 의존성을 주입함.

DI를 통해 의존성을 외부에서 주입하여 다형성을 이용하여 유연하게 객체들을 사용할 수 있음 또한 코드의 결합도를 낮추어 유연하게 변경이 가능하게 만들어줌 

하나의 코드를 보면
```
public class MemberRegisterService { 
//의존 객체를 직접 생성
private MemberDao memberDao = new MemberDao();
//의존하는 MemberDao의 객체도 함께 생성
MemberRegisterService svc = new MemberRegisterService();
```
위 코드는 클래스 내부에 직접 의존하는 객체를 생성해서 사용하려고 new를 써서 의존하는 클래스를 불러오는 코드이다.

이는 생성은 쉽지만 유지보수 측면에서 문제점을 유발한다.

이를 위해 DI를 사용하여 객체를 직접 생성하는 대신 의존 객체를 전달 받는 방식으로 사용한다.

아래의  DI 코드를 보면 직접 객체를 생성하지 않고 생성자를 통해서 의존 객체를 전달 받는다.

즉 MemberRegisterService가 MemberDao 의 객체를 주입 받은 것.

```
2.
public MemberRegisterService(MemberDao memberDao){
	this.memberDao = memberDao;
}
```

Di는 변경의 유연함 때문에 사용한다. 만약 이미 만들어진 MemberDao의 객체 정보에 기능을 제공하는 changeMemberDao 클래스를 하나 더 만들어야 한다고 가정해보자.

```
3.
public class changeMemberDao extends MemberDao{
}
```

MemberDao 의 정보를 changeMemberDao 가 상속 받고 new 를 써서 만든 1번 코드 MemberDao  객체와 관련된 클래스 하나하나의 소스를 changeMemberDao  다 바꿔줘야한다. 

그게 수량이 많다면 변경에 있어서 유연함이 없다고 하는 것이다.  

하지만 DI를 사용하면 한번만 변경하면 끝
```
2번과 같이 MemberRegisterService안에 MemberDao를 주입
객체 생성
MemberDao memberDao = new MemberDao();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
3번 코드에 다형성을 이용한 객체 생성 코드를 한번만 변경하면 사용가능
MemberDao memberDao = new changeMemberDao ();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
```

DI의 실제 객체는 main 메서드에 생성하는데 이 방법 보다는 객체를 생성하고 의존 객체를 주입해주는 클래스를 따로 작성하는 것이 좋다.

즉 의존성 전용 클래스를 만드는 것. 레고의 조립 클래스 느낌으로 프로팰러, 바퀴, 몸통을 연결해주는 느낌으로. 
```
public class Lego
private MemberDao memberDao;
private MemberRegisterService regSvc;

public Lego(){
memberDao = new MemberDao();
regSvc = new MemberRegisterService(memberDao);

여기서 만약 changeMemberDao 를 써야한다면

public Lego(){
memberDao = new changeMemberDao ();
regSvc = new MemberRegisterService(memberDao);
```


참고사항: 그래들의 의존성도 찾아보니 지정된 의존들의 프로그램을 가져오는 건 맞지만 DI의 패턴과는 다른 점이 있음, DI는 객체 간의 의존성을 런타임에 주입하는 것이지만 그래들의 디펜던시스는 빌드 타임에 필요한 라이브러리를 제공해줌.

즉 서로의 의존성 목적이 다르다고 볼 수 있다.
한마디로 그래들이나 메이븐은 빌드타임의 의존 라이브러리를 받는 목적으로 DI 패턴을 사용하진 않는다.

DI 패턴은 주로 생성자 주입, 세터 주입, 인터페이스 주입 등을 통해 의존성을 주입하는데, 스프링 프레임워크에서는 이를 구현하기 위해 @Autowired 어노테이션을 제공한다
</details>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>

# 2번 박호범


## 웹기초 HTTP

<details>

HyperText Transfer Protocol 간단하게 말해서 HTML의 내용물(자원)을 담는 상자 내용물은 크게 요청/응답 줄, 헤더, 몸체 세 개의 영역이 있다.

요청 규칙: 브라우저가 서버에 HTML 을 요청할때
헤더 : 서버가 응답을 생성하는데 참조 할 수 있는 정보를 전송 ( 브라우저 종류나 언어 )
몸체 : 정보를 전송해야할 때 사용 ( 파일 업로드 )

응답 규칙: 서버가 브라우저에 HTML 을 전송할때
헤더 : 응답에 대한 정보를 전송 ( 응답의 몸체 데이터와 길이 등)
몸체 : 웹 브라우저가 요청한 자원의 내용 ( HTML 문서나 이미지 파일 데이터 ) 
</details>



## 스프링 : 스프링 DI(Dependency Injection - 의존주입)

<details>
</details>


<hr>
<hr>
<hr>
<hr>
<hr>
<hr>



# 3번 임나라님

## 웹기초 HTTP : 요청 전문(헤더, 바디)
<details>

헤더는 요청 또는 응답에 대한 정보를 가지고 있는 곳이고 바디는 서버와 클라이언트 간에 주고받을 실제 데이터를 담아두는 공간입니다.

**일반 헤더(General header)** :
요청 응답에 모두 적용 가능한 헤더이다.
메시지, 연결 관리 (Connection Management), 캐싱 정책 등을 제공한다.

**요청 헤더(Request header)** :
클라이언트가 서버에 요청할 때 이용되는 헤더이다.
클라이언트가 사용하는 언어정보 (languages), 유저 에이전트 (user agent) 와 받아들이는 미디어 타입에 대한 정보 (content-type) 등이 포함되어 있다.

**대표적 요청 헤더에는**
> **Host :** 요청하려는 서버 호스트 이름과 포트번호
>
> **User-Agent** : 클라이언트 프로그램 정보 ex) Mozilla/4.0, Windows NT5.1
>
> **Referer** : 현재 페이지로 연결되는 링크가 있던 이전 웹 페이지의 주소
>
> **Accept** : 클라이언트가 처리 가능한 MIME Type 종류 나열
>
> **Accept-Language** : 클라이언트가 지원가능한 언어 나열
>
> **Cookie :** 쿠기 값 key-value로 표현된다. Set-Cookie 헤더와 함께 서버로부터 이전에 전송됐던 저장된 HTTP 쿠키를 포함

Body (본문)
- POST, PUT 요청과 같이 **요청과 함께 전달되는 데이터**를 포함한다.
  - 요청과 함께 전달되는 데이터가 없을 경우 Body가 없을 수도 있다.

<!--
헤더: 호스트의 이름 또는 IP주소, 브라우저의 종류, 쿠키 정보 개발자도구 페이지에 가면 정보가 나와있음
헤더(header) : 사용자 요청 정보
    - 요청 URL, 
    - 요청 PATH,  
    - 요청 브라우저 설정(언어-Accept-Language, 브라우저 종류 - user-agent),  
    - 요청 쪽 IP, 
    - 요청 방식(GET, POST), 
    - 쿠키
바디(body)
     - 요청 쪽 전송 데이터 (POST)
     - 요청 헤더 Content-Type application/x-www-form-urlencoded;
     -요청 바디 : 키=값&키=값
              값 → URL 인코딩(16진수로 전환)
     -요청 헤더: Content-Type: application/json
     -요청 바디: { “키”: “값”, “키”: “값” }
     -->

</details>


## 스프링 : 의존성 자동 주입
<details>
의존 대상을 설정 코드에서 직접 주입하기 않고 스프링이 자동으로 의존하는 빈 객체를 주입해주는 기능도 있다. 이를 자동 주입이라 한다.

<mark >스프링에서 의존 자동 주입을 설정하려면 @Autowired 애노테이션이나 @Resource 애노테이션을 사용하면 된다. 스프링에서는 주로 **@Autowired**를 많이 사용한다.</mark>

**@Autowired 애노테이션을 이용한 의존 자동 주입**
자동 주입 기능을 사용하면 스프링이 알아서 의존 객체를 찾아서 주입한다.

자동 주입 기능을 사용하는 방법은 의존을 주입할 대상에 @Autowired 애노테이션을 붙이기만 하면 된다.

@Autowired 애노테이션을 **필드**나 **Setter 메서드**에 붙이면 스프링은 타입이 일치하는 빈 객체를 찾아서 주입한다.

---

### 일치하는 빈이 없는 경우
@Autowired 애노테이션을 적용한 대상에 일치하는 빈이 없으면 UnsatisfiedDependencyException이 발생한다.

### @Autowired 애노테이션을 붙인 주입 대상에 일치하는 빈이 두 개 이상인 경우
@Qualifier는 추가 구분자를 넣어주는 방식이다.
-   빈 등록과 주입시 파라미터에 Qaulifier 이름을 추가하여 검색을 시도한다.

@Primary는 동일 타입 빈이 매칭되면 해당 빈을 우선 주입하라는 뜻이다.

@Primary와 @Qualifier가 겹치면 @Qualifier가 우선순위를 가져간다.

</details>

<hr>
<hr>
<hr>
<hr>
<hr>
<hr>

# 4번 손미희님


## 웹기초 : 응답 전문(헤더, 바디)
<details>
헤더: 클라이언트에게 보내는 응답에 대한 부가적인 정보 키와 쌍으로 이루어져 있으며 정보를 제공 함 아이디 비번을 입력하면 이것을 처리함(?)
헤더(header) ; 
      - 응답 데이터에 대한 정보
           예) content-type : 응답 body 데이터 종류 (text/html), application/json, image/png…)
       - 응답 서버 정보…
      - 서버쪽 → 브라우저 쪽 명령
            Location : 주소 → 브라우저 주소 이동
            Set-Cookie : 키 = 값; 키 =값 → 브라우저 쿠키 저장소 저장
            content-Disposition: attachment=  “파일명” : → 출력을 파일로 변경 : 다운로드
            Refresh: 초→ 초 주기마다 브라우저를 새로고침
       - 응답 상태 코드 오류 번호 200~500번대
바디(body) : 응답 데이터 .
스프링 : 컴포넌트 스캔
</details>

<hr>
<hr>
<hr>
<hr>
<hr>
<hr>

# 5번 송현수님
## 웹기초 : 요청 방식(GET, POST, PUT, PATCH, DELETE)
<details>
GET : URL에 파라미터를 붙여서 전송 즉, (?)쿼리스트링 문자열을 포함해서 요청 그래서 폼을 사용하지 않고 주소창에 입력만 해도 파마미터로 전송하여 결과가 웹 페이지에 출력된다 파라미터 길이에 제한이 있을 수 있다.

GET: 서버 자원 조회,  서버 자원을 가져오고자 할 때 사용합니다. 요청의 본문에 데이터를 넣지 않습니다. 데이터를 서버로 보내야 한다면 쿼리스트링을 사용합니다.
POST: 데이터 변화 서버에 자원을 새로 등록 할 때 사용 요청의 본문에 새로 등록할 데이터를 넣어 보냄
PUT : 데이터 치환. 서버 자원을 요청에 들어 있는 자원 치환 할 때 사용 요청 본문 치환할 데이터 넣어 보냄
PATCH : 부분 수정. 서버 자원의 일부만 수정하고자 할 때 사용. 요청 본문 일부 수정할 데이터 넣어 보냄
DELETE : 서버의 자원을 삭제하고자 할 때 사용합니다. 요청의 본문에 데이터를 넣지 않습니다.
OPTIONS : 요청을 하기 전에 통신 옵션을 설명하기 위해 사용합니다.
</details>

## 스프링 : 빈라이프사이클
<details>
</details>

<hr>
<hr>
<hr>
<hr>
<hr>
<hr>


# 6번 박범수님


## 웹기초 : 응답상태(2xx, 3xx, 4xx, 5xx)
<details>
2XX : 성공을 알리는 상태코드 입니다. 
          200(성공), 
          201(작성됨)이 많이 사용됩니다.
3XX : 리다이렉션(다른 페이지로 이동)을 알리는 상태 코드 입니다. 어떤 주소를 입력했는데 다른 주소의 페이지로 넘어갈 때 이 코드가 사용됩니다. 
          301(영구이동), 
          302(임시 이동) 
          304(수정되지 않음)는 요청의 응답으로 캐시를 사용했다는 뜻 입니다.
4XX : 요청 오류를 나타냅니다. 요청 자체에 오류가 있을 때 표시됩니다. 
          400(잘못된 요청), 
          401(권한없음), 
          403(금지됨), 
          404(찾을 수 없음), 
          405(메서드 처리 불가 Method Not Allowed)가 있습니다.
5XX : 서버오류를 나타냅니다. 특히 코드 오류나 물리적 서버 오류 때 발생하며 요청은 제대로 왔지만 서버에 오류가 생겼을 때 발생합니다. 이 오류가 뜨지 않게 주의해서 프로그래밍 해야 합니다. 
          500(코드 오류, 내부 서버 오류), 
          501&502(불량 게이트웨이), 
          503(서비스를 사용할 수 없음)이 자주 사용됩니다.
</details>
          
## 스프링 : AOP
<details>
</details>