# 1.고원일님
## 웹기초 : 요청과 응답 이해하기
<details>
</details>

## 스프링 : DI란?
<details>
</details>

# 2번 박호범님
## 웹기초 HTTP
<details>

</details>

## 스프링 : 스프링 DI(Dependency Injection - 의존주입)
<details>
</details>

# 3번 임나라님
## 웹기초 : 요청 전문(헤더, 바디)
<details>
</details>

## 스프링 : 의존성 자동 주입
<details>
</details>
# 4번 손미희님
## 웹기초 : 응답 전문(헤더, 바디)
<details>

# 4번 손미희
## 웹기초 : 응답 전문(헤더, 바디)
### 응답 (Response)
서버가 클라이언트로 보내는 메세지.

- Header
  - 응답에 대한 부가적인 정보
    Server (응답)
    서버의 소프트웨어 정보

### Header 항목
Set-Cooke
- 서버측에서 클라이언트에게 세션 쿠키 정보를 설정한다.


Age
- 캐시 응답. max-age 시간 내에서 얼마나 흘렀는지 초단위로 알려준다.
- Ex) max-age= 3600을 설정한 경우, 1분 후 Age: 60이 캐시 응답 헤더에 포함된다.


Cache-Control
- 웹 브라우저나 중간 서버와 같은 클라이언트 캐시에서 데이터의 캐싱 동작을 제어하는데 사용 된다.
- no-store : 클라이언트나 중간 서버에서 데이터를 저장하지 않아야 함을 뜻한다. 보안적인 이유로 민감한 정보가 포힘된 데이터의 경우에 사용한다. 캐시를 사용하지 않음을 뜻한다.
- no-cache : 클라이언트가 데이터를 캐시에 저장하지 않고 매번 서버로부터 다시 요청해야 함을 나타낸다.
  캐시를 사용하기 전에 서버에게 검사를 받고 데이터가 변경되지 않았다면 캐시를 사
  용한다.
- must-revalidate : 캐시 만료 후 최초 조회 시 원 서버에 검증 받아야 한다.


Content-Encoding
- 큰 HTML 문서를 압축해 전송 시간을 줄이기 위해서 사용한다.
- 혹은 허락받지 않은 제 3자가 볼 수 없게 콘텐츠를 암호화하거나 뒤섞어 보내는 목적으로 사용한다.
- 콘텐츠의 포맷과 연관되어있다.
- gzip, compress, defalte, identity와 같은 알고리즘 사용한다.
- 발송하는 쪽에서 콘텐츠에 적용한다.


Content-Type
- 컨텐츠의 미디어 타입, 문자 인코딩


Date
- 메시지가 보내진 날짜와 시간
- Wed, 13 Dec 2023 10:26:25 GMT


Location
- 300번대 응답이나 201 Created 응답일 때 어느 페이지로 이동할지를 알려주는 헤더

- Body (본문)
  서버가 클라이언트에게 응답할 데이터가 존재할 경우 해당 데이터를 담고 있다.

</details>

## 스프링 : 컴포넌트 스캔
<details>

# 컴포넌트스캔
- 스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능.
- 이전까지는 설정 정보에 직접 스프링 빈을 등록, 나열했는데 등록해야 할 빈의 수가 많아지면 일일히 등록하기 번거롭고, 설정 정보도 커지고, 누락 문제도 발생.
- 설정 클래스에서 빈으로 등록하지 않아도 원하는 클래스를 빈으로 등록할 수 있으므로 컴포넌트스캔 기능을 사용하면 설정 코드가 크게 줄어든다.
- 또한 의존 관계를 자동으로 주입하는 @Autowired 기능도 제공한다.

## 1. @Component
- 스프링이 검색해서 빈으로 등록할 수 있으려면 클래스에 @Component 어노테이션을 붙여야 한다.

- @Component 어노테이션에서 빈의 이름을 지정하지 않을 경우, 클래스 이름의 맨 앞글자를 소문자로 바꿔 자체 등록하여 사용한다.

## 2. @ComponentScan 어노테이션으로 스캔 대상 설정 및 제외하기
- @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록하려면 우선 설정 클래스에 @ComponentScan 어노테이션을 적용해야 한다.
- 기존의 설정 클래스와는 다르게 자동으로 스프링 빈을 등록하기 때문에 클래스 내부에 @Bean으로 등록한 클래스가 존재하지 않는다.
- 컴포넌트 스캔은 이름 그대로 @Component 어노테이션이 붙은 클래스를 스캔해 스프링 빈으로 등록한다.

- basePackages에 속성을 등록해 스캔 대상 패키지 목록을 지정한다.
- @ComponentScan (basePackages = {”spring})은 현재 프로젝트내에 존재하는 spring 패키지와 spring 패키지 하위 패키지에 속한 모든 클래스를 스캔 대상으로 설정한다는 의미이다.
- 반면 excludeFilters 속성을 사용하면 스캔할 때 특정 대상을 자동 등록 대상에서 제외할 수 있다.

- type 속성값으로 FilterType.ANNOTATION을 사용하면 classes 속성에서 필터로 사용할 어노테이션 타입을 값으로 준다. @ManualBean이 붙은 클래스는 스캔 대상에서 제외한다.


### 기본 스캔 대상
@Component 어노테이션 뿐만 아니라 @Controller, @Service, @Repository, @Aspect, @Configuration 어노테이션이 붙은 클래스도 스캔 대상에 포함된다.

## 3. 컴포넌트 스캔에 따른 충돌 처리
- 컴포넌트 스캔 기능을 사용해서 자동으로 빈을 등록할 때는 중복된 빈 이름으로 인한 충돌에 주의해야 하는데, 스캔할 때 빈 이름이 같은 경우 수동 등록한 빈이 우선 스캔된다.

- 컴포넌트 스캔 기능을 이용할 때 다른 패키지에 같은 이름의 클래스가 존재할 경우
  @ComponentScan (basePackages = {”spring”, “spring2”}로 스캔 범위를 설정하고 스프링 컨테이너를 생성하면 spring2 패키지에 있는 MemberRefisterService 클래스를 빈으로 등록할 때, 빈 이름인 memberRefisterService 가 spring 패키지에 있는 MemberRefisterService 클래스의 빈과 타입이 다르다고 충돌이 일어난다.

## 4. 컴포넌트 스캔과 자동 의존 주입
@Autowired
- 생성자에 @Autowired 어노테이션을 지정하면, 스프링컨테이너가 자동으로 해당 스프링을 찾아 주입한다.
- 이 때, 기본 조회 전략은 타입이 같은 클래스의 빈 또는 해당 타입의 후손 클래스의 빈을 찾아서 주입하는 것니다.
  - getBean(MemberRepository.class)와 동일하다고 이해하면 된다.
  - 같은 타입이 여러 개 있는 경우 충돌 발생
- 생성 파라메터가 많아도 다 찾아서 자동으로 주입한다.


</details>


# 5번 송현수님
## 웹기초 : 요청 방식(GET, POST, PUT, PATCH, DELETE)
<details>
</details>

## 스프링 : 빈라이프사이클
<details>
</details>

# 6번 박범수님
## 웹기초 : 응답상태(2xx, 3xx, 4xx, 5xx)
<details>
</details>

## 스프링 : AOP
<details>
</details>