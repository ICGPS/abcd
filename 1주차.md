# 1.고원일님
## 웹기초 : 요청과 응답 이해하기
<details>
</details>

## 스프링 : DI란?
<details>
</details>

# 2번 박호범님
## 웹기초 HTTP
<details>

</details>

## 스프링 : 스프링 DI(Dependency Injection - 의존주입)
<details>
</details>

# 3번 임나라님
## 웹기초 : 요청 전문(헤더, 바디)
<details>
</details>

## 스프링 : 의존성 자동 주입
<details>
</details>



# 4번 손미희님



## 웹기초 : 응답 전문(헤더, 바디)
<details>
헤더는 요청 또는 응답에 대한 정보를 가지고 있는 곳이고 바디는 서버와 클라이언트 간에 주고받을 실제 데이터를 담아두는 공간입니다.

**일반 헤더(General header)** :
요청 응답에 모두 적용 가능한 헤더이다.
메시지, 연결 관리 (Connection Management), 캐싱 정책 등을 제공한다.

**요청 헤더(Request header)** :
클라이언트가 서버에 요청할 때 이용되는 헤더이다.
클라이언트가 사용하는 언어정보 (languages), 유저 에이전트 (user agent) 와 받아들이는 미디어 타입에 대한 정보 (content-type) 등이 포함되어 있다.

**대표적 요청 헤더에는**
> **Host :** 요청하려는 서버 호스트 이름과 포트번호
>
> **User-Agent** : 클라이언트 프로그램 정보 ex) Mozilla/4.0, Windows NT5.1
>
> **Referer** : 현재 페이지로 연결되는 링크가 있던 이전 웹 페이지의 주소
>
> **Accept** : 클라이언트가 처리 가능한 MIME Type 종류 나열
>
> **Accept-Language** : 클라이언트가 지원가능한 언어 나열
>
> **Cookie :** 쿠기 값 key-value로 표현된다. Set-Cookie 헤더와 함께 서버로부터 이전에 전송됐던 저장된 HTTP 쿠키를 포함

Body (본문)
- POST, PUT 요청과 같이 **요청과 함께 전달되는 데이터**를 포함한다.
  - 요청과 함께 전달되는 데이터가 없을 경우 Body가 없을 수도 있다.

<!--
헤더: 호스트의 이름 또는 IP주소, 브라우저의 종류, 쿠키 정보 개발자도구 페이지에 가면 정보가 나와있음
헤더(header) : 사용자 요청 정보
    - 요청 URL, 
    - 요청 PATH,  
    - 요청 브라우저 설정(언어-Accept-Language, 브라우저 종류 - user-agent),  
    - 요청 쪽 IP, 
    - 요청 방식(GET, POST), 
    - 쿠키
바디(body)
     - 요청 쪽 전송 데이터 (POST)
     - 요청 헤더 Content-Type application/x-www-form-urlencoded;
     -요청 바디 : 키=값&키=값
              값 → URL 인코딩(16진수로 전환)
     -요청 헤더: Content-Type: application/json
     -요청 바디: { “키”: “값”, “키”: “값” }
     -->

### 응답 (Response)
서버가 클라이언트로 보내는 메세지.

- Header
  - 응답에 대한 부가적인 정보
    Server (응답)
    서버의 소프트웨어 정보

### Header 항목
Set-Cooke
- 서버측에서 클라이언트에게 세션 쿠키 정보를 설정한다.


Age
- 캐시 응답. max-age 시간 내에서 얼마나 흘렀는지 초단위로 알려준다.
- Ex) max-age= 3600을 설정한 경우, 1분 후 Age: 60이 캐시 응답 헤더에 포함된다.


Cache-Control
- 웹 브라우저나 중간 서버와 같은 클라이언트 캐시에서 데이터의 캐싱 동작을 제어하는데 사용 된다.
- no-store : 클라이언트나 중간 서버에서 데이터를 저장하지 않아야 함을 뜻한다. 보안적인 이유로 민감한 정보가 포힘된 데이터의 경우에 사용한다. 캐시를 사용하지 않음을 뜻한다.
- no-cache : 클라이언트가 데이터를 캐시에 저장하지 않고 매번 서버로부터 다시 요청해야 함을 나타낸다.
  캐시를 사용하기 전에 서버에게 검사를 받고 데이터가 변경되지 않았다면 캐시를 사
  용한다.
- must-revalidate : 캐시 만료 후 최초 조회 시 원 서버에 검증 받아야 한다.


Content-Encoding
- 큰 HTML 문서를 압축해 전송 시간을 줄이기 위해서 사용한다.
- 혹은 허락받지 않은 제 3자가 볼 수 없게 콘텐츠를 암호화하거나 뒤섞어 보내는 목적으로 사용한다.
- 콘텐츠의 포맷과 연관되어있다.
- gzip, compress, defalte, identity와 같은 알고리즘 사용한다.
- 발송하는 쪽에서 콘텐츠에 적용한다.


Content-Type
- 컨텐츠의 미디어 타입, 문자 인코딩


Date
- 메시지가 보내진 날짜와 시간
- Wed, 13 Dec 2023 10:26:25 GMT


Location
- 300번대 응답이나 201 Created 응답일 때 어느 페이지로 이동할지를 알려주는 헤더

- Body (본문)
  서버가 클라이언트에게 응답할 데이터가 존재할 경우 해당 데이터를 담고 있다.

</details>

## 스프링 : 컴포넌트 스캔
<details>

# 컴포넌트스캔
- 스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능.
- 이전까지는 설정 정보에 직접 스프링 빈을 등록, 나열했는데 등록해야 할 빈의 수가 많아지면 일일히 등록하기 번거롭고, 설정 정보도 커지고, 누락 문제도 발생.
- 설정 클래스에서 빈으로 등록하지 않아도 원하는 클래스를 빈으로 등록할 수 있으므로 컴포넌트스캔 기능을 사용하면 설정 코드가 크게 줄어든다.
- 또한 의존 관계를 자동으로 주입하는 @Autowired 기능도 제공한다.

## 1. @Component
- 스프링이 검색해서 빈으로 등록할 수 있으려면 클래스에 @Component 어노테이션을 붙여야 한다.

- @Component 어노테이션에서 빈의 이름을 지정하지 않을 경우, 클래스 이름의 맨 앞글자를 소문자로 바꿔 자체 등록하여 사용한다.

## 2. @ComponentScan 어노테이션으로 스캔 대상 설정 및 제외하기
- @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록하려면 우선 설정 클래스에 @ComponentScan 어노테이션을 적용해야 한다.
- 기존의 설정 클래스와는 다르게 자동으로 스프링 빈을 등록하기 때문에 클래스 내부에 @Bean으로 등록한 클래스가 존재하지 않는다.
- 컴포넌트 스캔은 이름 그대로 @Component 어노테이션이 붙은 클래스를 스캔해 스프링 빈으로 등록한다.

- basePackages에 속성을 등록해 스캔 대상 패키지 목록을 지정한다.
- @ComponentScan (basePackages = {”spring})은 현재 프로젝트내에 존재하는 spring 패키지와 spring 패키지 하위 패키지에 속한 모든 클래스를 스캔 대상으로 설정한다는 의미이다.
- 반면 excludeFilters 속성을 사용하면 스캔할 때 특정 대상을 자동 등록 대상에서 제외할 수 있다.

## 기본 스캔 대상
@Component 어노테이션 뿐만 아니라 @Controller, @Service, @Repository, @Aspect, @Configuration 어노테이션이 붙은 클래스도 스캔 대상에 포함된다.


## 3. 컴포넌트 스캔에 따른 충돌 처리
- 컴포넌트 스캔 기능을 사용해서 자동으로 빈을 등록할 때는 중복된 빈 이름으로 인한 충돌에 주의해야 하는데, 스캔할 때 빈 이름이 같은 경우 수동 등록한 빈이 우선 스캔된다.

## 스프링 : 의존성 자동 주입

의존 대상을 설정 코드에서 직접 주입하기 않고 스프링이 자동으로 의존하는 빈 객체를 주입해주는 기능도 있다. 이를 자동 주입이라 한다.

스프링에서 의존 자동 주입을 설정하려면 @Autowired 애노테이션이나 @Resource 애노테이션을 사용하면 된다. 스프링에서는 주로 **@Autowired**를 많이 사용한다.

**@Autowired 애노테이션을 이용한 의존 자동 주입**
자동 주입 기능을 사용하면 스프링이 알아서 의존 객체를 찾아서 주입한다.

자동 주입 기능을 사용하는 방법은 의존을 주입할 대상에 @Autowired 애노테이션을 붙이기만 하면 된다.

@Autowired 애노테이션을 **필드**나 **Setter 메서드**에 붙이면 스프링은 타입이 일치하는 빈 객체를 찾아서 주입한다.

---

### 일치하는 빈이 없는 경우
- @Autowired 애노테이션을 적용한 대상에 일치하는 빈이 없으면 UnsatisfiedDependencyException이 발생한다.

### @Autowired 애노테이션을 붙인 주입 대상에 일치하는 빈이 두 개 이상인 경우
- @Qualifier는 추가 구분자를 넣어주는 방식이다.
  -   빈 등록과 주입시 파라미터에 Qaulifier 이름을 추가하여 검색을 시도한다.

- @Primary는 동일 타입 빈이 매칭되면 해당 빈을 우선 주입하라는 뜻이다.

- @Primary와 @Qualifier가 겹치면 @Qualifier가 우선순위를 가져간다.




- 컴포넌트 스캔 기능을 이용할 때 다른 패키지에 같은 이름의 클래스가 존재할 경우
  @ComponentScan (basePackages = {”spring”, “spring2”}로 스캔 범위를 설정하고 스프링 컨테이너를 생성하면 spring2 패키지에 있는 MemberRefisterService 클래스를 빈으로 등록할 때, 빈 이름인 memberRefisterService 가 spring 패키지에 있는 MemberRefisterService 클래스의 빈과 타입이 다르다고 충돌이 일어난다.

## 4. 컴포넌트 스캔과 자동 의존 주입
@Autowired
- 생성자에 @Autowired 어노테이션을 지정하면, 스프링컨테이너가 자동으로 해당 스프링을 찾아 주입한다.
- 이 때, 기본 조회 전략은 타입이 같은 클래스의 빈 또는 해당 타입의 후손 클래스의 빈을 찾아서 주입하는 것니다.
  - getBean(MemberRepository.class)와 동일하다고 이해하면 된다.
  - 같은 타입이 여러 개 있는 경우 충돌 발생
- 생성 파라메터가 많아도 다 찾아서 자동으로 주입한다.


</details>


# 5번 송현수님
## 웹기초 : 요청 방식(GET, POST, PUT, PATCH, DELETE)
<details>
</details>

## 스프링 : 빈라이프사이클
<details>
</details>

# 6번 박범수님
## 웹기초 : 응답상태(2xx, 3xx, 4xx, 5xx)
<details>

### **HTTP 상태 코드**
    
1xx (조건부 응답) - 요청받음, 프로세스 계속.   
임시, 실험적인 상태. → 클라이언트로 보내면 안된다.
    
2xx (요청 수신, 처리 성공) 
    
    200 : 정상 응답 (요청 -> 서버 -> 응답)
    201 : 작성됨(CREATED)
    
3xx (리다이렉션 완료 : 다른 페이지로 이동)

    301 : 영구 이동 - get 또는 haed 요청에 대한 응답
    302 : 임시 이동 - 현재 다른 위치이지만 원래 위치를 사용할 때 (redirect)
    304 : 캐시됨 - 마지막 요청 이후 페이지가 수정되지 않았다. (요청의 응답으로 캐시를 사용했다는 뜻)
    
4xx : 요청 오류

 	400 : 잘못된 요청(BAD REQUEST) - 서버가 구문 인식 못함.
 	401 : 권한 없음(UNAUTHORIZED) - 인증 안됨(로그인이 필요한 페이지)
 	403 : 금지됨(FORBIDDEN) - 권한 없음
 	404 : 페이지 없음(NOT FOUND) 
 	405 : Method Not Allowed - POST 요청받는 서버에 GET으로 요청/ GET 요청받는 서버에 POST로 요청

5xx : 서버 오류

    500 - 내부 서버 오류(Internal Server Error) - 코드 오류, 서버 물리적 오류
    501, 502 (불량 게이트웨이)
    503 (서비스를 사용할 수 없음)

</details>

## 스프링 : AOP
<details>

</details>

211

### **AOP**

@EnableApectJAutoProxy : 프록시 설정 활성

```java
@Configuration
@EnableAspectJAutoProxy(proxyTargetClass = true) // 하위클래스 기반의 프록시
public class AppCtx {
    @Bean
    public Calculator calculator() {
        return new RecCalculator();
    }

    @Bean
    public ProxyCache proxyCache() {
        return new ProxyCache();
    }

    @Bean
    public ProxyCalculator proxyCalculator() {
        return new ProxyCalculator();
    }
}
```

1)**@Aspect** : **공통 기능**이 포함된 **클래스**

```java
import aopex.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Aspect     // aop
@Order(2)
public class ProxyCalculator {

    @Around("CommonPointcut.publicTarget()")
    public Object process(ProceedingJoinPoint joinPoint) throws Throwable {

        long stime = System.nanoTime(); // 공통 기능

        try {
            Object result = joinPoint.proceed(); // 핵심 기능을 대신 수행하는 메서드
            // factorial(...)

            return result;
        } finally {
            long etime = System.nanoTime(); // 공통 기능
            System.out.printf("걸린시간 : %d%n", etime - stime);
        }
    }
}
```

```java
@Aspect
@Order(1)
public class ProxyCache {

    private Map<Long, Object> cacheData = new HashMap<>();

    @Around("CommonPointcut.publicTarget()")
    public Object process(ProceedingJoinPoint joinPoint) throws Throwable {

        Object[] args = joinPoint.getArgs(); // 매개변수로 투입된 인자 값( 예 - 10L)
        Long num = (Long)args[0];
        if (cacheData.containsKey(num)) {
            System.out.println("캐시값 사용!");
            return cacheData.get(num);
        }

        Object result = joinPoint.proceed(); // ProxyCalculator::proceed()

        // 캐시 저장
        cacheData.put(num, result);
        System.out.println("캐시 저장!");

        return result;
    }
}
```

2) **@Pointcut** : 공통 기능이 적용될 **범위**

- execution 명시자

```java
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class CommonPointcut {
    @Pointcut("execution(* aopex..*(long))")  // A
    public void publicTarget() {}
}
```

3) **@Around** : 공통 기능을 수행하고 핵심 기능을 대신 수행 주는 **메서드**

ProceedingJoinPoint joinPoint

Signature getSignature()

getName() : 메서드명
toLongString() : 자세한 메서드 이름 정보

 Object proceed() : 핵심 기능 대신 수행해 주는 메서드(범용 기능)
 Object[] getArgs()
 Object getTarget() : 핵심 기능 메서드가 속해 있는 객체의 참조 변수

1. @Order
    
    ProxyCache -> ProxyCalculator :  정상
    
    ProxyCaluclator -> ProxyCache : 캐시 동작 X
    
    프록시의 실행 순서가 매우 중요한 경우 @Order -> 순서를 직접 지정
    
    ```java
    @Aspect
    @Order(2)
    public class ProxyCalculator {
    	(...)
    }
    ```
    
    ```java
    @Aspect
    @Order(1)  // 우선 순위
    public class ProxyCache {
    	(...)
    }
    ```
    
2. 프록시 생성방식
    - 반복
        
        ```java
        public static void main(String[] args) {
                long stime = System.nanoTime();     // 공통 기능
        
                // 핵심 기능
                ImplCalculator cal1 = new ImplCalculator(); // 반복문
                long result1 = cal1.factorial(10L);
                System.out.printf("cal1 : %d%n", result1);
        
                long etime = System.nanoTime();     // 공통 기능
                System.out.printf("반복문으로 걸린 시간 : %d%n", etime - stime);
        
                stime = System.nanoTime();          // 공통 기능
        
                // 핵심 기능
                RecCalculator cal2 = new RecCalculator();   // 재귀 : 스택이 쌓여서 성능에 좋지 않다.
                long result2 = cal2.factorial(10L);
                System.out.printf("cal2 : %d%n", result2);
        
                etime = System.nanoTime();          //공통 기능
                System.out.printf("재귀문으로 걸린 시간 : %d%n", etime - stime);
            }   // 왜 재귀문이 더 짧지?
        }       // 반복되는 코드를 프록시로 묶어서 처리하려고 한다. -> Ex02
        ```
        
    - 프록시로
        
        ```java
        public class ProxyCalculator implements Calculator{
            private Calculator calculator;
        
            public ProxyCalculator(Calculator calculator) {
                this.calculator = calculator;
            }
            @Override
            public long factorial(long num) {
                long stime = System.nanoTime();     // 공통 기눙
        
                try {
        
                    long result = calculator.factorial(num);     // 핵심 기능
        
                    return result;
                } finally {
                    long etime = System.nanoTime();     // 공통 기능
                    System.out.printf("걸린시간 : %d%n", etime - stime);
                }
            }
        }
        ```
        
        ```java
        public static void main(String[] args) {
                // 데코레이션 패턴. 추가적인 기능을 더한다.
                // 기능을 대신 수행하기 때문에 프록시라고 부른다.
                ProxyCalculator cal1 = new ProxyCalculator(new ImplCalculator());
                long result1 = cal1.factorial(10L);
                System.out.printf("cal1 : %d%n", result1);
        
                ProxyCalculator cal2 = new ProxyCalculator(new RecCalculator());
                long result2 = cal2.factorial(10L);
                System.out.printf("cal2 : %d%n", result2);
            }
        }
        ```
        
    
3. @Around의 Pointcut 설정과 @Pointcut 재사용
    
    ```java
    @Aspect
    public class CommonPointcut {
        @Pointcut("execution(* aopex..*(long))")
        public void publicTarget() {}
    }
    ```
    
    위 pointcut을 아래에서 재사용
    
    ```java
    @Around("CommonPointcut.publicTarget()")
    public Object process(ProceedingJoinPoint joinPoint) throws Throwable {
    	(...)
    }
    ```
</details> 
