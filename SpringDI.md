# Spring DI 

## DI : Dependency Injection(의존성 주입)
 - 객체 지향 프로그래밍에서 사용되는 설계 패턴 중 하나로, 객체 간의 의존성을 외부에서 주입하는 방법이다.
 - DI를 통해 객체는 직접 자신이 필요로 하는 의존 객체를 생성하지 않고, 외부에서 주입 받아 사용한다.  
 - 즉, new 연산자를 통해 객체를 직접 생성하는 것이 아니라 외부에서 생성된 객체를 주입받아 이용하는 것이다.

### 의존성
- 객체가 다른 객체를 사용하고 있는 경우 즉, A객체가 없이는 B객체가 원하는 목적으로 사용될 수 없는 경우를 뜻한다.  
- 의존한다는 것은 의존 대상인 A객체가 변하면 그것이 B객체에 전달되고, A객체의 메소드가 변경되면 B객체에서도 그에 따른 수정이 필요한 것을 의미한다.  
- 또한 A객체의 형식은 그대로지만 로직이 변경되면 결과적으로 B객체의 기능에 영향을 미치는 것도 의존 관계에 있다고 할 수 있다.

### 따라서 의존성 주입은 두 객체 간의 관계를 맺어주는 것이다.

## DI(의존 주입)를 사용하는 이유
 - 코드의 재사용성, 유연성이 높아진다.  
&nbsp; - 하나의 작업만 수행하는 작은 객체는 많은 상황에서 재결합하고 재사용하기가 쉽기 때문이다.
 
 - 객체 간 결합도가 낮기 때문에 한 클래스를 수정했을 때 다른 클래스도 수정해야 하는 상황을 막아준다.
 
 - 유지보수가 쉬우며 테스트가 용이해진다.
 
 - 확장성을 가진다.

## IoC Inversion of Control(제어의 역전)   
 - 메소드나 객체의 호출작업을 개발자가 직접 하는 것이 아닌, 스프링 프레임워크에게 제어권을 넘기는 것이다. 
 - 대부분의 프레임워크에서 IoC를 적용하고 있고 스프링 또한 여러 프레임워크 중 하나이다.
 - @componentScan, @autowired 등을 예시로 들 수 있다.

## Spring DI : 스프링에서의 의존성 주입
 - 객체 간 의존성을 개발자가 객체 내부에서 직접 호출(new 연산자 생성)하는 대신, 외부(스프링 컨테이너)에서 객체를 생성 후 주입해주는 방식이다.  
 - 외부(스프링 컨테이너)에서 두 객체 간의 관계 설정을 해주는 디자인 패턴으로, 인터페이스를 사이에 두어 클래스 레벨에서는 의존 관계가 고정되지 않도록 한다.  
 - 런타임 시 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮춘다.    

## 의존성 주입의 3가지 방법  
  
### 1. 생성자 주입  
 - 클래스에 생성자를 만든 후 @Autowired를 붙여 의존성을 주입받는 방법
 -  Spring 4.3 이후 클래스 내 생성자가 하나이고, 그 생성자로 주입받을 객체가 빈으로 등록되어 있다면 @Autowired를 생략 가능하다.
 -  객체의 성격에 맞게, 빈의 이름이 달라질 수 있다.
 - 생성자 주입은 인스턴스 생성 시 1회 호출되는 것이 보장되기 때문에, 주입 받은 객체가 변하지 않거나 반드시 객체 주입이 필요한 경우 강제하기 위해 사용된다.
 -  생성자를 2회 이상 정의할 수 없다.  

### 2. 필드 주입  
 - 코드가 간결하고 편하지만 의존 관계를 정확히 파악하기 함들다.    
 - 필드 주입 시 final 키워드를 선언할 수 없어 객체가 변할 수 있다.   
 - 주입이 동시에 일어나 겹치는 경우 순환참조 에러가 발생한다.    

### 3. 수정자(setter) 주입    
 - setter 혹은 사용자 정의 메소드를 통해 의존 관계 주입한다.    
 - setter의 경우 객체가 변경될 필요성(주입하는 객체를 변경하는 경우는 드묾)이 있을 때만 사용한다.    

## 스프링에서는 생성자 주입을 권장하는 이유
 
### 객체 불변성 확보  
 - 객체의 생성자는 객체 생성 시 최초 1회만 호출되기 때문에 주입 받은 객체가 불변 객체(메소드 변화 X)여야 하거나 반드시 해당 객체의 주입이 필요한 경우 사용한다.  
 - 생성자로 한번 의존 관계를 주입하면 생성자는 최초 1회 이후 다시 생성될 일이 없기 때문에 불변객체가 보장된다.

### 테스트 용이
 - 필드 주입으로 작성된 경우, 순수 자바 코드로 단위테스트를 실행하는 것이 불가능하다.
 - 메인 코드는 Spring과 같은 DI 프레임워크 위에서 동작하는데 단위테스트 시 단독적으로 실행되므로 의존관계 주입이 NULL 상태여서 NullPoninterException이 발생한다.
 - 생성자 주입 시 단독으로 실행할 때도 의존관계 주입이 성립된다.

### 순환참조 에러 방지
 - 순환참조 에러 : A객체는 B객체를 참조하고, B객체는 A객체를 참조해 두 객체가 서로를 동시에 참조할 때 발생한다.


### 의존성을 필드로 혹은 수정자(setter)로 주입시킬 경우, 프로그램 실행 중 에러가 발생한다.
 - 이때 컴파일 시에는 아무런 에러가 없다가 메소드 호출시에 발생한다는 것이 큰 문제가 된다.


### 이러한 이유들 때문에 여러 DI 방법 중 생성자주입 방식을 권장하고 있다.

### 의존성을 생성자로 주입했을 때는 컴파일 에러 발생으로 프로그램 실행 자체가 되지 않으므로 서비스 전 에러를 해결 할 수 있다.
